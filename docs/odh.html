<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1">
<meta name="generator" content="pdoc3 0.11.6">
<title>CryoToolBox.odh API documentation</title>
<meta name="description" content="odh - Oxygen Deficiency Hazard analysis tool …">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/13.0.0/sanitize.min.css" integrity="sha512-y1dtMcuvtTMJc1yPgEqF0ZjQbhnc/bFhyvIyVNb9Zk5mIGtqVaAB1Ttl28su8AvFMOY0EwRbAe+HCLqj6W7/KA==" crossorigin>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/13.0.0/typography.min.css" integrity="sha512-Y1DYSb995BAfxobCkKepB1BqJJTPrOp3zPL74AWFugHHmmdcvO+C48WLrUOlhGMc0QG7AE3f7gmvvcrmX2fDoA==" crossorigin>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/default.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:1.5em;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:2em 0 .50em 0}h3{font-size:1.4em;margin:1.6em 0 .7em 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .2s ease-in-out}a:visited{color:#503}a:hover{color:#b62}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900;font-weight:bold}pre code{font-size:.8em;line-height:1.4em;padding:1em;display:block}code{background:#f3f3f3;font-family:"DejaVu Sans Mono",monospace;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source > summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible;min-width:max-content}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em 1em;margin:1em 0}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul ul{padding-left:1em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script type="text/x-mathjax-config">MathJax.Hub.Config({ tex2jax: { inlineMath: [ ['$','$'], ["\\(","\\)"] ], processEscapes: true } });</script>
<script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.7/latest.js?config=TeX-AMS_CHTML" integrity="sha256-kZafAc6mZvK3W3v1pHOcUix30OHQN6pU/NO2oFkqZVw=" crossorigin></script>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js" integrity="sha512-D9gUyxqja7hBtkWpPWGt9wfbfaMGVt9gnyCvYa+jojwwPHLCzUm5i8rpk7vD7wNee9bA35eYIjobYPaQuKS1MQ==" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => {
hljs.configure({languages: ['bash', 'css', 'diff', 'graphql', 'ini', 'javascript', 'json', 'plaintext', 'python', 'python-repl', 'rust', 'shell', 'sql', 'typescript', 'xml', 'yaml']});
hljs.highlightAll();
/* Collapse source docstrings */
setTimeout(() => {
[...document.querySelectorAll('.hljs.language-python > .hljs-string')]
.filter(el => el.innerHTML.length > 200 && ['"""', "'''"].includes(el.innerHTML.substring(0, 3)))
.forEach(el => {
let d = document.createElement('details');
d.classList.add('hljs-string');
d.innerHTML = '<summary>"""</summary>' + el.innerHTML.substring(3);
el.replaceWith(d);
});
}, 100);
})</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>CryoToolBox.odh</code></h1>
</header>
<section id="section-intro">
<p>odh - Oxygen Deficiency Hazard analysis tool.</p>
<p>Based on Fermilab ES&amp;H Manual chapter 4240 (see
<a href="https://eshq.fnal.gov/manuals/feshm/">https://eshq.fnal.gov/manuals/feshm/</a>)</p>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="CryoToolBox.odh.O2_sudden_release"><code class="name flex">
<span>def <span class="ident">O2_sudden_release</span></span>(<span>release, volume, escape=False)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def O2_sudden_release(release, volume, escape=False):
    &#34;&#34;&#34;Calculate oxygen concentration after a sudden release.

    Parameters
    ----------
    release : Quantity [length*3]
        Standard volume of the inert gas released.
    volume : Quantity [length^3]
        Volume of the room, building, or area analyzed.
    escape : bool, optional
        If True, mixed air is allowed to escape from considered volume.
        If False, inert gas is trapped and expels the air outside the considered volume.
        Default is False.

    Returns
    -------
    float
        Resulting oxygen concentration.
    &#34;&#34;&#34;
    if escape:
        O2_conc = 0.21*volume/(volume+release)
    else:
        O2_conc = 0.21*(1-release/volume)
    return O2_conc</code></pre>
</details>
<div class="desc"><p>Calculate oxygen concentration after a sudden release.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>release</code></strong> :&ensp;<code>Quantity [length*3]</code></dt>
<dd>Standard volume of the inert gas released.</dd>
<dt><strong><code>volume</code></strong> :&ensp;<code>Quantity [length^3]</code></dt>
<dd>Volume of the room, building, or area analyzed.</dd>
<dt><strong><code>escape</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>If True, mixed air is allowed to escape from considered volume.
If False, inert gas is trapped and expels the air outside the considered volume.
Default is False.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>float</code></dt>
<dd>Resulting oxygen concentration.</dd>
</dl></div>
</dd>
<dt id="CryoToolBox.odh.PFD_avg"><code class="name flex">
<span>def <span class="ident">PFD_avg</span></span>(<span>l_du, l_dd, T_p, MTTR)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def PFD_avg(l_du, l_dd, T_p, MTTR):
    &#34;&#34;&#34;
    Calculate probability of failure on demand based on dangerous detected and dangerous undetected failure rates.

    The equation is taken from MSA Ultima X5000 safety manual.

    Parameters
    ----------
    l_du : Quantity [1/time]
        Dangerous undetected failure rate.
    l_dd : Quantity [1/time]
        Dangerous detected failure rate.
    T_p : Quantity [time]
        Proof test interval.
    MTTR : Quantity [time]
        Mean time to restoration.

    Returns
    -------
    float
        Probability of failure on demand.
    &#34;&#34;&#34;
    PFD_du = l_du * (T_p/2 + MTTR)
    PFD_dd = l_dd * MTTR
    PFD = PFD_du + PFD_dd
    return float(PFD)</code></pre>
</details>
<div class="desc"><p>Calculate probability of failure on demand based on dangerous detected and dangerous undetected failure rates.</p>
<p>The equation is taken from MSA Ultima X5000 safety manual.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>l_du</code></strong> :&ensp;<code>Quantity [1/time]</code></dt>
<dd>Dangerous undetected failure rate.</dd>
<dt><strong><code>l_dd</code></strong> :&ensp;<code>Quantity [1/time]</code></dt>
<dd>Dangerous detected failure rate.</dd>
<dt><strong><code>T_p</code></strong> :&ensp;<code>Quantity [time]</code></dt>
<dd>Proof test interval.</dd>
<dt><strong><code>MTTR</code></strong> :&ensp;<code>Quantity [time]</code></dt>
<dd>Mean time to restoration.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>float</code></dt>
<dd>Probability of failure on demand.</dd>
</dl></div>
</dd>
<dt id="CryoToolBox.odh.conc_after"><code class="name flex">
<span>def <span class="ident">conc_after</span></span>(<span>V, C_e, Q, t, t_e)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def conc_after(V, C_e, Q, t, t_e):
    &#34;&#34;&#34;Calculate the oxygen concentration in the confined volume after
    the release has ended.

    As defined by FESHM 4240 6.1.A, Case D.

    Parameters
    ----------
    V : ureg.Quantity, [length]^3
        Volume of the confined space.
    C_e : float
        Oxygen concentration at the end of the release.
    Q : ureg.Quantity, [length]^3/[time]
        Volumetric ventilation rate of fan(s); positive value corresponds
        to blowing air into the confined space, negative - drawing contaminated
        air outside.
    t : ureg.Quantity, [time]
        time, beginning of release is at `t`=0.
    t_e : ureg.Quantity, [time]
        time when release ended.

    Returns
    -------
    float
        Oxygen concentration.
    &#34;&#34;&#34;
    C = 0.21-(0.21-C_e)*math.e**-(abs(Q)/V*(t-t_e))
    return C</code></pre>
</details>
<div class="desc"><p>Calculate the oxygen concentration in the confined volume after
the release has ended.</p>
<p>As defined by FESHM 4240 6.1.A, Case D.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>V</code></strong> :&ensp;<code>ureg.Quantity, [length]^3</code></dt>
<dd>Volume of the confined space.</dd>
<dt><strong><code>C_e</code></strong> :&ensp;<code>float</code></dt>
<dd>Oxygen concentration at the end of the release.</dd>
<dt><strong><code>Q</code></strong> :&ensp;<code>ureg.Quantity, [length]^3/[time]</code></dt>
<dd>Volumetric ventilation rate of fan(s); positive value corresponds
to blowing air into the confined space, negative - drawing contaminated
air outside.</dd>
<dt><strong><code>t</code></strong> :&ensp;<code>ureg.Quantity, [time]</code></dt>
<dd>time, beginning of release is at <code>t</code>=0.</dd>
<dt><strong><code>t_e</code></strong> :&ensp;<code>ureg.Quantity, [time]</code></dt>
<dd>time when release ended.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>float</code></dt>
<dd>Oxygen concentration.</dd>
</dl></div>
</dd>
<dt id="CryoToolBox.odh.conc_final"><code class="name flex">
<span>def <span class="ident">conc_final</span></span>(<span>R, Q)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def conc_final(R, Q):
    &#34;&#34;&#34;Calculate the final oxygen concentration for continuous flow.

    Equivalent to conc_vent(V, R, Q, float(&#39;inf&#39;)).

    Parameters
    ----------
    R : ureg.Quantity, [length]^3/[time]
        Volumetric spill rate into confined space.
    Q : ureg.Quantity, [length]^3/[time]
        Volumetric ventilation rate of fan(s); positive value corresponds
        to blowing air into the confined space, negative - drawing contaminated
        air outside.

    Returns
    -------
    float
        Oxygen concentration.
    &#34;&#34;&#34;
    if Q &gt; 0:
        C = 0.21/(Q+R)*Q
    elif abs(Q) &lt;= abs(R):
        C = 0
    elif abs(Q) &gt; abs(R):
        C = 0.21*(1-R/abs(Q))
    return C</code></pre>
</details>
<div class="desc"><p>Calculate the final oxygen concentration for continuous flow.</p>
<p>Equivalent to conc_vent(V, R, Q, float('inf')).</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>R</code></strong> :&ensp;<code>ureg.Quantity, [length]^3/[time]</code></dt>
<dd>Volumetric spill rate into confined space.</dd>
<dt><strong><code>Q</code></strong> :&ensp;<code>ureg.Quantity, [length]^3/[time]</code></dt>
<dd>Volumetric ventilation rate of fan(s); positive value corresponds
to blowing air into the confined space, negative - drawing contaminated
air outside.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>float</code></dt>
<dd>Oxygen concentration.</dd>
</dl></div>
</dd>
<dt id="CryoToolBox.odh.conc_vent"><code class="name flex">
<span>def <span class="ident">conc_vent</span></span>(<span>V, R, Q, t)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def conc_vent(V, R, Q, t):
    &#34;&#34;&#34;Calculate the oxygen concentration at the end of the event.

    As defined by FESHM 4240 6.1.A, Cases A, B, and C.

    Parameters
    ----------
    V : ureg.Quantity, [length]^3
        Volume of the confined space.
    R : ureg.Quantity, [length]^3/[time]
        Volumetric spill rate into confined space.
    Q : ureg.Quantity, [length]^3/[time]
        Volumetric ventilation rate of fan(s); positive value corresponds
        to blowing air into the confined space, negative - drawing contaminated
        air outside.
    t : ureg.Quantity, [time]
        time, beginning of release is at `t` = 0.

    Returns
    -------
    float
        Oxygen concentration.
    &#34;&#34;&#34;
    if Q &gt; 0:
        C = 0.21/(Q+R) * (Q+R*math.e**-((Q+R)/V*t))
    elif abs(Q) &lt;= R:
        C = 0.21*math.e**-(R/V*t)
    elif abs(Q) &gt; R:
        C = 0.21*(1-R/abs(Q)*(1-math.e**-(abs(Q)*t/V)))
    return float(C)</code></pre>
</details>
<div class="desc"><p>Calculate the oxygen concentration at the end of the event.</p>
<p>As defined by FESHM 4240 6.1.A, Cases A, B, and C.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>V</code></strong> :&ensp;<code>ureg.Quantity, [length]^3</code></dt>
<dd>Volume of the confined space.</dd>
<dt><strong><code>R</code></strong> :&ensp;<code>ureg.Quantity, [length]^3/[time]</code></dt>
<dd>Volumetric spill rate into confined space.</dd>
<dt><strong><code>Q</code></strong> :&ensp;<code>ureg.Quantity, [length]^3/[time]</code></dt>
<dd>Volumetric ventilation rate of fan(s); positive value corresponds
to blowing air into the confined space, negative - drawing contaminated
air outside.</dd>
<dt><strong><code>t</code></strong> :&ensp;<code>ureg.Quantity, [time]</code></dt>
<dd>time, beginning of release is at <code>t</code> = 0.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>float</code></dt>
<dd>Oxygen concentration.</dd>
</dl></div>
</dd>
<dt id="CryoToolBox.odh.hole_leak"><code class="name flex">
<span>def <span class="ident">hole_leak</span></span>(<span>area,<br>fluid,<br>P_out=&lt;Quantity(14.696, &#x27;pound_force_per_square_inch&#x27;)&gt;,<br>Kd=0.62)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def hole_leak(area, fluid, P_out=P_NTP, Kd=0.62):
    &#34;&#34;&#34;Calculate leak flow rate through a hole in a pipe.

    Discharge flow through a hole is calculated using direct integration
    method from API 520 Annex B.

    Parameters
    ----------
    area : ureg.Quantity, [length]^2
        Area of the leak.
    fluid : heat_transfer.ThermState
        Thermodynamic state of the fluid stored in the source.
    P_out : ureg.Quantity, [mass]/([length]*[time]^2)
        Pressure at the exit of the hole.
    Kd : float, optional
        Discharge coefficient.
        For uneven holes 0.62 provides a good approximation.

    Returns
    -------
    ureg.Quantity, [length]^3/[time]
        Standard volumetric flow at Normal Temperature and Pressure.

    &#34;&#34;&#34;
    m_dot = G_nozzle(fluid) * area * Kd
    q_std = to_standard_flow(m_dot, fluid)
    return q_std</code></pre>
</details>
<div class="desc"><p>Calculate leak flow rate through a hole in a pipe.</p>
<p>Discharge flow through a hole is calculated using direct integration
method from API 520 Annex B.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>area</code></strong> :&ensp;<code>ureg.Quantity, [length]^2</code></dt>
<dd>Area of the leak.</dd>
<dt><strong><code>fluid</code></strong> :&ensp;<code>heat_transfer.ThermState</code></dt>
<dd>Thermodynamic state of the fluid stored in the source.</dd>
<dt><strong><code>P_out</code></strong> :&ensp;<code>ureg.Quantity, [mass]/([length]*[time]^2)</code></dt>
<dd>Pressure at the exit of the hole.</dd>
<dt><strong><code>Kd</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>Discharge coefficient.
For uneven holes 0.62 provides a good approximation.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>ureg.Quantity, [length]^3/[time]</code></dt>
<dd>Standard volumetric flow at Normal Temperature and Pressure.</dd>
</dl></div>
</dd>
<dt id="CryoToolBox.odh.prob_m_of_n"><code class="name flex">
<span>def <span class="ident">prob_m_of_n</span></span>(<span>m, n, T, l)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def prob_m_of_n(m, n, T, l):
    &#34;&#34;&#34;Calculate the probability of m out of n units working.

    Calculation is done using binomial distribution.

    Parameters
    ----------
    m : int
        Number of units working.
    n : int
        Total number of units.
    T : ureg.Quantity, [time]
        Test period
    l : ureg.Quantity, 1/[time]
        Failure rate (\\lambda) of a fan

    Returns
    -------
    float
        Probability of m out of n units working.
    &#34;&#34;&#34;
    PFD_one_unit = l*T/2
    m_of_n = binom(n, m) * (PFD_one_unit)**(n-m) * (1-PFD_one_unit)**m
    return m_of_n</code></pre>
</details>
<div class="desc"><p>Calculate the probability of m out of n units working.</p>
<p>Calculation is done using binomial distribution.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>m</code></strong> :&ensp;<code>int</code></dt>
<dd>Number of units working.</dd>
<dt><strong><code>n</code></strong> :&ensp;<code>int</code></dt>
<dd>Total number of units.</dd>
<dt><strong><code>T</code></strong> :&ensp;<code>ureg.Quantity, [time]</code></dt>
<dd>Test period</dd>
<dt><strong><code>l</code></strong> :&ensp;<code>ureg.Quantity, 1/[time]</code></dt>
<dd>Failure rate (\lambda) of a fan</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>float</code></dt>
<dd>Probability of m out of n units working.</dd>
</dl></div>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="CryoToolBox.odh.BuildPower"><code class="flex name class">
<span>class <span class="ident">BuildPower</span></span>
<span>(</span><span>power_pfd: float = &lt;Quantity(0.0003, &#x27;dimensionless&#x27;)&gt;,<br>backup_pfd: float = 1,<br>lambda_power: pint.Quantity = &lt;Quantity(0.0001, &#x27;1 / hour&#x27;)&gt;,<br>max_outage: pint.Quantity = &lt;Quantity(inf, &#x27;hour&#x27;)&gt;)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@ureg.check(None, None, &#39;1/[time]&#39;, &#39;[time]&#39;)
@dataclass
class BuildPower:
    &#34;&#34;&#34;
    Dataclass representing the electrical power failure scenario of a building.

    Attributes
    ----------
    power_pfd : float
        The probability of failure demand rate.
    backup_pfd : float
        The probability of backup system failure.
    lambda_power : ureg.Quantity, 1/[time]
        The rate of power failure occurrences.
    max_outage : ureg.Quantity, [time]
        The maximum duration of an outage.

    Properties
    ----------
    pfd : float
        The total probability of a power failure, taking into account both
        the power probability of failure on demand and the backup system
        reliability.

    Methods
    -------
    None
    &#34;&#34;&#34;
    power_pfd: float = TABLE_1[&#39;Electrical Power Failure&#39;][&#39;Demand rate&#39;]
    backup_pfd: float = 1
    lambda_power: ureg.Quantity = TABLE_1[&#39;Electrical Power Failure&#39;][&#39;Time rate&#39;]
    max_outage: ureg.Quantity = float(&#39;inf&#39;) * ureg.hr

    @property
    def pfd(self):
        return self.power_pfd * self.backup_pfd

    def info(self):
        return (f&#39;Power provided with {self.pfd:.3g~} unavailability and &#39;
                f&#39;{self.max_outage:.3g~} max outage period.&#39;
                f&#39;\nPower failure rate is {self.lambda_power:.3e~}.&#39;)</code></pre>
</details>
<div class="desc"><p>Dataclass representing the electrical power failure scenario of a building.</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>power_pfd</code></strong> :&ensp;<code>float</code></dt>
<dd>The probability of failure demand rate.</dd>
<dt><strong><code>backup_pfd</code></strong> :&ensp;<code>float</code></dt>
<dd>The probability of backup system failure.</dd>
<dt><strong><code>lambda_power</code></strong> :&ensp;<code>ureg.Quantity, 1/[time]</code></dt>
<dd>The rate of power failure occurrences.</dd>
<dt><strong><code>max_outage</code></strong> :&ensp;<code>ureg.Quantity, [time]</code></dt>
<dd>The maximum duration of an outage.</dd>
</dl>
<h2 id="properties">Properties</h2>
<p>pfd : float
The total probability of a power failure, taking into account both
the power probability of failure on demand and the backup system
reliability.</p>
<h2 id="methods">Methods</h2>
<p>None</p></div>
<h3>Instance variables</h3>
<dl>
<dt id="CryoToolBox.odh.BuildPower.backup_pfd"><code class="name">var <span class="ident">backup_pfd</span> : float</code></dt>
<dd>
<div class="desc"><p>The type of the None singleton.</p></div>
</dd>
<dt id="CryoToolBox.odh.BuildPower.lambda_power"><code class="name">var <span class="ident">lambda_power</span> : pint.Quantity</code></dt>
<dd>
<div class="desc"><p>The type of the None singleton.</p></div>
</dd>
<dt id="CryoToolBox.odh.BuildPower.max_outage"><code class="name">var <span class="ident">max_outage</span> : pint.Quantity</code></dt>
<dd>
<div class="desc"><p>The type of the None singleton.</p></div>
</dd>
<dt id="CryoToolBox.odh.BuildPower.pfd"><code class="name">prop <span class="ident">pfd</span></code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def pfd(self):
    return self.power_pfd * self.backup_pfd</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="CryoToolBox.odh.BuildPower.power_pfd"><code class="name">var <span class="ident">power_pfd</span> : float</code></dt>
<dd>
<div class="desc"><p>The type of the None singleton.</p></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="CryoToolBox.odh.BuildPower.info"><code class="name flex">
<span>def <span class="ident">info</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def info(self):
    return (f&#39;Power provided with {self.pfd:.3g~} unavailability and &#39;
            f&#39;{self.max_outage:.3g~} max outage period.&#39;
            f&#39;\nPower failure rate is {self.lambda_power:.3e~}.&#39;)</code></pre>
</details>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="CryoToolBox.odh.BuildVent"><code class="flex name class">
<span>class <span class="ident">BuildVent</span></span>
<span>(</span><span>Q_fan: pint.Quantity,<br>N_fans: int,<br>Test_period: pint.Quantity,<br>lambda_fan: pint.Quantity = &lt;Quantity(9e-06, &#x27;1 / hour&#x27;)&gt;,<br>const_vent: pint.Quantity = &lt;Quantity(0.0, &#x27;foot ** 3 / minute&#x27;)&gt;,<br>PFD_ODH: float = &lt;Quantity(0.002, &#x27;dimensionless&#x27;)&gt;)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@ureg.check(&#39;[length]^3/[time]&#39;, None, &#39;[time]&#39;, &#39;1/[time]&#39;,
            &#39;[length]^3/[time]&#39;, None)
@dataclass
class BuildVent:
    &#34;&#34;&#34;
    Dataclass representing the ventilation system of a building.

    Attributes
    ----------
    Q_fan : ureg.Quantity, [length]^3/[time]
        Volumetric flow of a single ODH fan installed in the volume.
    N_fans : int
        Number of fans installed.
    Test_period : ureg.Quantity, [time]
        Test period of the fans and dampers.
    lambda_fan : ureg.Quantity, 1/[time]
        Failure rate of the fans in the building.
    const_vent : ureg.Quantity, [length]^3/[time]
        Min volumetric flow required or present in the building.
    PFD_ODH : float
        The default value for the oxygen deficiency hazard (ODH) system failure.

    Properties
    ----------
    None

    Methods
    -------
    fan_flowrates() -&gt; List[Tuple[float, ureg.Quantity, int]]:
        Calculate (probability, flow, number of fans) tuples for all
        combinations of fans working. All fans are expected to have the same
        volumetric flow.
    &#34;&#34;&#34;

    Q_fan: ureg.Quantity
    N_fans: int
    Test_period: ureg.Quantity
    lambda_fan: ureg.Quantity = TABLE_2[&#39;Fan&#39;][&#39;Failure to run&#39;]
    const_vent: ureg.Quantity = 0*ureg.ft**3/ureg.min
    PFD_ODH: float = PFD_ODH  # Default value for ODH system failure

    def fan_flowrates(self):
        # TODO add fans with different volumetric rates (see report as well)
        fail_rate = self.lambda_fan
        fan_flowrates = []
        for m in range(self.N_fans+1):
            # Probability of exactly m units starting
            P_m_fan_work = prob_m_of_n(m, self.N_fans, self.Test_period,
                                       fail_rate)
            flowrate = self.Q_fan*m
            if flowrate == Q_(&#39;0 m**3/min&#39;):
                flowrate = self.const_vent
            fan_flowrates.append((P_m_fan_work, flowrate, m))
        return fan_flowrates

    def info(self):
        if self.Q_fan &gt; 0*ureg.L/ureg.s:
            vent_action = &#39;supplying clean air to&#39;
        else:
            vent_action = &#39;drawing contaminated air from&#39;
        result = [f&#39;Ventilation consists of {self.N_fans} fans {abs(self.Q_fan):,.0f~} each\n  {vent_action} the volume.&#39;]
        if self.const_vent &gt; 0*ureg.L/ureg.s:
            vent_action = &#39;supplying clean air to&#39;
        else:
            vent_action = &#39;drawing contaminated air from&#39;
        result.append(f&#39;Constant ventilation in the building is {abs(self.const_vent):,.1f~}\n  {vent_action} the volume.&#39;)
        if self.N_fans == 1:
            result.append(f&#39;ODH fan is tested every {self.Test_period:.1f~} and fan failure rate is {self.lambda_fan:.3e~}.&#39;)
        elif self.N_fans &gt; 1:
            result.append(f&#39;ODH fans are tested every {self.Test_period:.1f~} and failure rate of each fan is {self.lambda_fan:.3e~}.&#39;)
        result.append(f&#39;ODH system unavailability is {self.PFD_ODH:.3e}.&#39;)
        return &#39;\n&#39;.join(result)</code></pre>
</details>
<div class="desc"><p>Dataclass representing the ventilation system of a building.</p>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>Q_fan</code></strong> :&ensp;<code>ureg.Quantity, [length]^3/[time]</code></dt>
<dd>Volumetric flow of a single ODH fan installed in the volume.</dd>
<dt><strong><code>N_fans</code></strong> :&ensp;<code>int</code></dt>
<dd>Number of fans installed.</dd>
<dt><strong><code>Test_period</code></strong> :&ensp;<code>ureg.Quantity, [time]</code></dt>
<dd>Test period of the fans and dampers.</dd>
<dt><strong><code>lambda_fan</code></strong> :&ensp;<code>ureg.Quantity, 1/[time]</code></dt>
<dd>Failure rate of the fans in the building.</dd>
<dt><strong><code>const_vent</code></strong> :&ensp;<code>ureg.Quantity, [length]^3/[time]</code></dt>
<dd>Min volumetric flow required or present in the building.</dd>
<dt><strong><code>PFD_ODH</code></strong> :&ensp;<code>float</code></dt>
<dd>The default value for the oxygen deficiency hazard (ODH) system failure.</dd>
</dl>
<h2 id="properties">Properties</h2>
<p>None</p>
<h2 id="methods">Methods</h2>
<p>fan_flowrates() -&gt; List[Tuple[float, ureg.Quantity, int]]:
Calculate (probability, flow, number of fans) tuples for all
combinations of fans working. All fans are expected to have the same
volumetric flow.</p></div>
<h3>Instance variables</h3>
<dl>
<dt id="CryoToolBox.odh.BuildVent.N_fans"><code class="name">var <span class="ident">N_fans</span> : int</code></dt>
<dd>
<div class="desc"><p>The type of the None singleton.</p></div>
</dd>
<dt id="CryoToolBox.odh.BuildVent.PFD_ODH"><code class="name">var <span class="ident">PFD_ODH</span> : float</code></dt>
<dd>
<div class="desc"><p>The type of the None singleton.</p></div>
</dd>
<dt id="CryoToolBox.odh.BuildVent.Q_fan"><code class="name">var <span class="ident">Q_fan</span> : pint.Quantity</code></dt>
<dd>
<div class="desc"><p>The type of the None singleton.</p></div>
</dd>
<dt id="CryoToolBox.odh.BuildVent.Test_period"><code class="name">var <span class="ident">Test_period</span> : pint.Quantity</code></dt>
<dd>
<div class="desc"><p>The type of the None singleton.</p></div>
</dd>
<dt id="CryoToolBox.odh.BuildVent.const_vent"><code class="name">var <span class="ident">const_vent</span> : pint.Quantity</code></dt>
<dd>
<div class="desc"><p>The type of the None singleton.</p></div>
</dd>
<dt id="CryoToolBox.odh.BuildVent.lambda_fan"><code class="name">var <span class="ident">lambda_fan</span> : pint.Quantity</code></dt>
<dd>
<div class="desc"><p>The type of the None singleton.</p></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="CryoToolBox.odh.BuildVent.fan_flowrates"><code class="name flex">
<span>def <span class="ident">fan_flowrates</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def fan_flowrates(self):
    # TODO add fans with different volumetric rates (see report as well)
    fail_rate = self.lambda_fan
    fan_flowrates = []
    for m in range(self.N_fans+1):
        # Probability of exactly m units starting
        P_m_fan_work = prob_m_of_n(m, self.N_fans, self.Test_period,
                                   fail_rate)
        flowrate = self.Q_fan*m
        if flowrate == Q_(&#39;0 m**3/min&#39;):
            flowrate = self.const_vent
        fan_flowrates.append((P_m_fan_work, flowrate, m))
    return fan_flowrates</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="CryoToolBox.odh.BuildVent.info"><code class="name flex">
<span>def <span class="ident">info</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def info(self):
    if self.Q_fan &gt; 0*ureg.L/ureg.s:
        vent_action = &#39;supplying clean air to&#39;
    else:
        vent_action = &#39;drawing contaminated air from&#39;
    result = [f&#39;Ventilation consists of {self.N_fans} fans {abs(self.Q_fan):,.0f~} each\n  {vent_action} the volume.&#39;]
    if self.const_vent &gt; 0*ureg.L/ureg.s:
        vent_action = &#39;supplying clean air to&#39;
    else:
        vent_action = &#39;drawing contaminated air from&#39;
    result.append(f&#39;Constant ventilation in the building is {abs(self.const_vent):,.1f~}\n  {vent_action} the volume.&#39;)
    if self.N_fans == 1:
        result.append(f&#39;ODH fan is tested every {self.Test_period:.1f~} and fan failure rate is {self.lambda_fan:.3e~}.&#39;)
    elif self.N_fans &gt; 1:
        result.append(f&#39;ODH fans are tested every {self.Test_period:.1f~} and failure rate of each fan is {self.lambda_fan:.3e~}.&#39;)
    result.append(f&#39;ODH system unavailability is {self.PFD_ODH:.3e}.&#39;)
    return &#39;\n&#39;.join(result)</code></pre>
</details>
<div class="desc"></div>
</dd>
</dl>
</dd>
<dt id="CryoToolBox.odh.ConstLeak"><code class="flex name class">
<span>class <span class="ident">ConstLeak</span></span>
<span>(</span><span>name: str,<br>fluid: <a title="CryoToolBox.cp_wrapper.ThermState" href="cp_wrapper.html#CryoToolBox.cp_wrapper.ThermState">ThermState</a>,<br>q_std: pint.Quantity,<br>tau: pint.Quantity)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@ureg.check(None, None, &#39;[length]^3/[time]&#39;, None)
@dataclass
class ConstLeak:
    name: str
    fluid: ThermState
    q_std: ureg.Quantity
    tau: ureg.Quantity
    _is_const = True
    # TODO Remove once isinstance() issue resolved</code></pre>
</details>
<div class="desc"><p>ConstLeak(name: str, fluid: CryoToolBox.cp_wrapper.ThermState, q_std: pint.Quantity, tau: pint.Quantity)</p></div>
<h3>Instance variables</h3>
<dl>
<dt id="CryoToolBox.odh.ConstLeak.fluid"><code class="name">var <span class="ident">fluid</span> : <a title="CryoToolBox.cp_wrapper.ThermState" href="cp_wrapper.html#CryoToolBox.cp_wrapper.ThermState">ThermState</a></code></dt>
<dd>
<div class="desc"><p>The type of the None singleton.</p></div>
</dd>
<dt id="CryoToolBox.odh.ConstLeak.name"><code class="name">var <span class="ident">name</span> : str</code></dt>
<dd>
<div class="desc"><p>The type of the None singleton.</p></div>
</dd>
<dt id="CryoToolBox.odh.ConstLeak.q_std"><code class="name">var <span class="ident">q_std</span> : pint.Quantity</code></dt>
<dd>
<div class="desc"><p>The type of the None singleton.</p></div>
</dd>
<dt id="CryoToolBox.odh.ConstLeak.tau"><code class="name">var <span class="ident">tau</span> : pint.Quantity</code></dt>
<dd>
<div class="desc"><p>The type of the None singleton.</p></div>
</dd>
</dl>
</dd>
<dt id="CryoToolBox.odh.ConstLeakNoVent"><code class="flex name class">
<span>class <span class="ident">ConstLeakNoVent</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ConstLeakNoVent(Exception):
    pass</code></pre>
</details>
<div class="desc"><p>Common base class for all non-exit exceptions.</p></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li>builtins.Exception</li>
<li>builtins.BaseException</li>
</ul>
</dd>
<dt id="CryoToolBox.odh.ConstLeakTooBig"><code class="flex name class">
<span>class <span class="ident">ConstLeakTooBig</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ConstLeakTooBig(Exception):
    pass</code></pre>
</details>
<div class="desc"><p>Common base class for all non-exit exceptions.</p></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li>builtins.Exception</li>
<li>builtins.BaseException</li>
</ul>
</dd>
<dt id="CryoToolBox.odh.FailureMode"><code class="flex name class">
<span>class <span class="ident">FailureMode</span></span>
<span>(</span><span>name: str,<br>source: <a title="CryoToolBox.odh.Source" href="#CryoToolBox.odh.Source">Source</a>,<br>fluid: <a title="CryoToolBox.cp_wrapper.ThermState" href="cp_wrapper.html#CryoToolBox.cp_wrapper.ThermState">ThermState</a>,<br>phi: pint.Quantity,<br>O2_conc: float,<br>leak_fr: pint.Quantity,<br>P_i: pint.Quantity,<br>F_i: float,<br>outage: bool,<br>q_leak: pint.Quantity,<br>tau: pint.Quantity,<br>Q_fan: pint.Quantity,<br>N_fan: int,<br>N: int,<br>is_const: bool,<br>scenario: str)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@ureg.check(None, None, None, &#39;1/[time]&#39;, None, &#39;1/[time]&#39;, &#39;1/[time]&#39;,
            None, None, &#39;[length]^3/[time]&#39;, &#39;[time]&#39;,
            &#39;[length]^3/[time]&#39;, None, None, None, None)
@dataclass
class FailureMode:
    &#34;&#34;&#34;Describes ODH failure modes, a combination of a leak and response to it.&#34;&#34;&#34;
    name: str
    source: Source
    fluid: ThermState
    phi: ureg.Quantity
    O2_conc: float
    leak_fr: ureg.Quantity
    P_i: ureg.Quantity
    F_i: float
    outage: bool
    q_leak: ureg.Quantity
    tau: ureg.Quantity
    Q_fan: ureg.Quantity
    N_fan: int
    N: int
    is_const: bool
    scenario: str</code></pre>
</details>
<div class="desc"><p>Describes ODH failure modes, a combination of a leak and response to it.</p></div>
<h3>Instance variables</h3>
<dl>
<dt id="CryoToolBox.odh.FailureMode.F_i"><code class="name">var <span class="ident">F_i</span> : float</code></dt>
<dd>
<div class="desc"><p>The type of the None singleton.</p></div>
</dd>
<dt id="CryoToolBox.odh.FailureMode.N"><code class="name">var <span class="ident">N</span> : int</code></dt>
<dd>
<div class="desc"><p>The type of the None singleton.</p></div>
</dd>
<dt id="CryoToolBox.odh.FailureMode.N_fan"><code class="name">var <span class="ident">N_fan</span> : int</code></dt>
<dd>
<div class="desc"><p>The type of the None singleton.</p></div>
</dd>
<dt id="CryoToolBox.odh.FailureMode.O2_conc"><code class="name">var <span class="ident">O2_conc</span> : float</code></dt>
<dd>
<div class="desc"><p>The type of the None singleton.</p></div>
</dd>
<dt id="CryoToolBox.odh.FailureMode.P_i"><code class="name">var <span class="ident">P_i</span> : pint.Quantity</code></dt>
<dd>
<div class="desc"><p>The type of the None singleton.</p></div>
</dd>
<dt id="CryoToolBox.odh.FailureMode.Q_fan"><code class="name">var <span class="ident">Q_fan</span> : pint.Quantity</code></dt>
<dd>
<div class="desc"><p>The type of the None singleton.</p></div>
</dd>
<dt id="CryoToolBox.odh.FailureMode.fluid"><code class="name">var <span class="ident">fluid</span> : <a title="CryoToolBox.cp_wrapper.ThermState" href="cp_wrapper.html#CryoToolBox.cp_wrapper.ThermState">ThermState</a></code></dt>
<dd>
<div class="desc"><p>The type of the None singleton.</p></div>
</dd>
<dt id="CryoToolBox.odh.FailureMode.is_const"><code class="name">var <span class="ident">is_const</span> : bool</code></dt>
<dd>
<div class="desc"><p>The type of the None singleton.</p></div>
</dd>
<dt id="CryoToolBox.odh.FailureMode.leak_fr"><code class="name">var <span class="ident">leak_fr</span> : pint.Quantity</code></dt>
<dd>
<div class="desc"><p>The type of the None singleton.</p></div>
</dd>
<dt id="CryoToolBox.odh.FailureMode.name"><code class="name">var <span class="ident">name</span> : str</code></dt>
<dd>
<div class="desc"><p>The type of the None singleton.</p></div>
</dd>
<dt id="CryoToolBox.odh.FailureMode.outage"><code class="name">var <span class="ident">outage</span> : bool</code></dt>
<dd>
<div class="desc"><p>The type of the None singleton.</p></div>
</dd>
<dt id="CryoToolBox.odh.FailureMode.phi"><code class="name">var <span class="ident">phi</span> : pint.Quantity</code></dt>
<dd>
<div class="desc"><p>The type of the None singleton.</p></div>
</dd>
<dt id="CryoToolBox.odh.FailureMode.q_leak"><code class="name">var <span class="ident">q_leak</span> : pint.Quantity</code></dt>
<dd>
<div class="desc"><p>The type of the None singleton.</p></div>
</dd>
<dt id="CryoToolBox.odh.FailureMode.scenario"><code class="name">var <span class="ident">scenario</span> : str</code></dt>
<dd>
<div class="desc"><p>The type of the None singleton.</p></div>
</dd>
<dt id="CryoToolBox.odh.FailureMode.source"><code class="name">var <span class="ident">source</span> : <a title="CryoToolBox.odh.Source" href="#CryoToolBox.odh.Source">Source</a></code></dt>
<dd>
<div class="desc"><p>The type of the None singleton.</p></div>
</dd>
<dt id="CryoToolBox.odh.FailureMode.tau"><code class="name">var <span class="ident">tau</span> : pint.Quantity</code></dt>
<dd>
<div class="desc"><p>The type of the None singleton.</p></div>
</dd>
</dl>
</dd>
<dt id="CryoToolBox.odh.Leak"><code class="flex name class">
<span>class <span class="ident">Leak</span></span>
<span>(</span><span>name: str,<br>failure_rate: pint.Quantity,<br>fluid: <a title="CryoToolBox.cp_wrapper.ThermState" href="cp_wrapper.html#CryoToolBox.cp_wrapper.ThermState">ThermState</a>,<br>q_std: pint.Quantity,<br>tau: pint.Quantity,<br>N_events: int)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@ureg.check(None, &#39;1/[time]&#39;, None, &#39;[length]^3/[time]&#39;, &#39;[time]&#39;, None)
@dataclass
class Leak:
    &#34;&#34;&#34;Describe inert gas leak from a Source&#34;&#34;&#34;
    name: str
    failure_rate: ureg.Quantity
    fluid: ThermState
    q_std: ureg.Quantity
    tau: ureg.Quantity
    N_events: int
    _is_const = False</code></pre>
</details>
<div class="desc"><p>Describe inert gas leak from a Source</p></div>
<h3>Instance variables</h3>
<dl>
<dt id="CryoToolBox.odh.Leak.N_events"><code class="name">var <span class="ident">N_events</span> : int</code></dt>
<dd>
<div class="desc"><p>The type of the None singleton.</p></div>
</dd>
<dt id="CryoToolBox.odh.Leak.failure_rate"><code class="name">var <span class="ident">failure_rate</span> : pint.Quantity</code></dt>
<dd>
<div class="desc"><p>The type of the None singleton.</p></div>
</dd>
<dt id="CryoToolBox.odh.Leak.fluid"><code class="name">var <span class="ident">fluid</span> : <a title="CryoToolBox.cp_wrapper.ThermState" href="cp_wrapper.html#CryoToolBox.cp_wrapper.ThermState">ThermState</a></code></dt>
<dd>
<div class="desc"><p>The type of the None singleton.</p></div>
</dd>
<dt id="CryoToolBox.odh.Leak.name"><code class="name">var <span class="ident">name</span> : str</code></dt>
<dd>
<div class="desc"><p>The type of the None singleton.</p></div>
</dd>
<dt id="CryoToolBox.odh.Leak.q_std"><code class="name">var <span class="ident">q_std</span> : pint.Quantity</code></dt>
<dd>
<div class="desc"><p>The type of the None singleton.</p></div>
</dd>
<dt id="CryoToolBox.odh.Leak.tau"><code class="name">var <span class="ident">tau</span> : pint.Quantity</code></dt>
<dd>
<div class="desc"><p>The type of the None singleton.</p></div>
</dd>
</dl>
</dd>
<dt id="CryoToolBox.odh.ODHError"><code class="flex name class">
<span>class <span class="ident">ODHError</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ODHError(Exception):
    pass</code></pre>
</details>
<div class="desc"><p>Common base class for all non-exit exceptions.</p></div>
<h3>Ancestors</h3>
<ul class="hlist">
<li>builtins.Exception</li>
<li>builtins.BaseException</li>
</ul>
</dd>
<dt id="CryoToolBox.odh.Source"><code class="flex name class">
<span>class <span class="ident">Source</span></span>
<span>(</span><span>name, fluid, volume, N=1, PFD_isol_valve=1)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Source:
    &#34;&#34;&#34;Source of inert gas
    &#34;&#34;&#34;
    def __init__(self, name, fluid, volume, N=1, PFD_isol_valve=1):
        &#34;&#34;&#34;Define the possible source of inert gas.

        Parameters
        ----------
        name : str
            Name of the source.
        fluid : heat_transfer.ThermState
            Thermodynamic state of the fluid stored in the source.
        liquid_volume : ureg.Quantity, [length]^3
            Liquid volume of the source.
        volume : ureg.Quantity, [length]^3
            Standard volume of the fluid contained in the source.
        N : int
            Number of the sources if several similar sources exist,
            e.g. gas bottles.
        PFD_isol_valve : float
            Probability of failure on demand of source isolation valve.
            If no isolation valve will trigger on ODH alarm, the probability
            is 1 (default).
        &#34;&#34;&#34;
        self.name = name
        self.fluid = fluid
        self.leaks = []
        # Number of sources if multiple exist, e.g. gas cylinders
        # Increases probability of failure by N.
        self.N = N
        # Calculating volume at standard conditions
        temp_state = fluid.copy()
        temp_state.update(&#39;T&#39;, T_NTP, &#39;P&#39;, P_NTP)
        self.liquid_volume = volume
        self.volume = volume*fluid.Dmass/temp_state.Dmass
        self.volume.ito_base_units()
        # By default assume there is no isolation valve
        # that is used by ODH system
        self.PFD_isol_valve = PFD_isol_valve

    def add_pipe_failure(self, tube, fluid, q_std_rupture=None, N_welds=1):
        &#34;&#34;&#34;Add pipe failure to the leaks dict.

        For a given tube calculate leak parameters as following:
        - failure rate
        - standard volumetric flow
        - duration of the release
        - number of possible similar events
        for all failure modes for piping and welds listed in Table 2 of
        FESHM 4240.

        Failure modes are analyzed by `Volume.odh` method.

        Parameters
        ----------
        tube : heat_transfer.piping.Tube
        fluid : heat_transfer.ThermState
            Thermodynamic state of the fluid for the release.
        q_std_rupture : ureg.Quantity, [length]^3/[time]
            Standard volumetric flow rate for pipe rupture.
        N_welds : int
            Number of welds on the tube.
        &#34;&#34;&#34;
        # Failure rate coefficients; Piping failure rate is per unit of length,
        # weld is dependent on number of welds, pipe OD and wall thickness
        failure_rate_coeff = {&#39;Piping&#39;: (tube.L, 1),
                              &#39;Pipe weld&#39;: (tube.OD / tube.wall,
                                            N_welds)}
        # Piping and weld leaks as per Table 2
        for cause, fr_coefs in failure_rate_coeff.items():
            for mode in TABLE_2[cause].keys():
                if tube.D &gt; 2 or mode != &#39;Large leak&#39;:  # Large leak only for D &gt; 2&#34;
                    name = f&#39;{cause} {mode.lower()}: {tube}&#39;
                    fr_coef, N_events = fr_coefs
                    if fr_coef.magnitude == 0:
                        raise ODHError(&#39;Failure rate should not be 0 &#39;
                                       f&#39;{cause} {mode}.&#39;)
                    if N_events == 0:
                        continue
                    if mode == &#39;Rupture&#39;:
                        failure_rate = fr_coef * TABLE_2[cause][mode]
                        if q_std_rupture is not None:
                            q_std = q_std_rupture
                        else:
                            area = tube.area
                            q_std = hole_leak(area, fluid)
                    else:
                        failure_rate = fr_coef * \
                            TABLE_2[cause][mode][&#39;Failure rate&#39;]
                        area = TABLE_2[cause][mode][&#39;Area&#39;]
                        if area &gt; tube.area:
                            ODHError(&#39;Leak area cannot be larger&#39;
                                     &#39; than pipe area.&#39;)
                        q_std = hole_leak(area, fluid)
                    self.add_failure_mode(name, failure_rate, fluid, q_std,
                                          N_events)

    def add_dewar_insulation_failure(self, q_std):
        &#34;&#34;&#34;Add dewar insulation failure to leaks dict.

        Store failure rate, flow rate and expected time duration of the
        failure event for the dewar insulation failure. Based on FESHM4240.
        Failure modes are analyzed by `Volume.odh` method.

        Parameters
        ----------
        q_std : ureg.Quantity, [length]^3/[time]
            Standard volumetric flow rate of the relief for the case of
            dewar insulation failure.
        &#34;&#34;&#34;
        failure_rate = TABLE_1[&#39;Dewar&#39;][&#39;Loss of vacuum&#39;]
        self.add_failure_mode(&#39;Dewar insulation failure&#39;, failure_rate,
                              self.fluid, q_std, 1)

    def add_flange_failure(self, pipe, fluid, q_std_rupture=None, N=1,
                           gasket_type=&#39;reinforced&#39;, blowout_area=None):
        &#34;&#34;&#34;Add reinforced or preformed gasket flange failure
        to leaks dict.

        Store failure rate, flow rate and expected time duration of
        the event for transfer line failure. Based on FESHM 4240.
        Failure modes are analyzed by `Volume.odh` method.

        Parameters
        ----------
        pipe : heat_transfer.Pipe
        fluid : heat_transfer.ThermState
            Thermodynamic state of the fluid stored in the source.
        q_std_rupture : ureg.Quantity, [length]^3/[time]
            Standard volumetric flow rate for flange rupture.
        N : int
            Number of reinforced seal connections on the pipe.
        gasket_type : str
            Type of the gasket in the flange, &#39;soft&#39; or &#39;reinforced&#39;.
        blowout_area : Quantity [length^2]
            Leak area in case of the soft gasket blowout. Not applicable for reinforced gaskets.
        &#34;&#34;&#34;
        # TODO Make leak and rupture areas adjustable, add info to docstring
        if gasket_type == &#39;reinforced&#39;:
            table = TABLE_2[&#39;Flange, reinforced gasket&#39;]
        if gasket_type == &#39;soft&#39;:
            table = TABLE_2[&#39;Flange, soft gasket&#39;]
        # Leak case
        name = f&#39;Flange {gasket_type} gasket leak: {pipe}&#39;
        failure_rate = table[&#39;Leak&#39;][&#39;Failure rate&#39;]
        area = table[&#39;Leak&#39;][&#39;Area&#39;]
        q_std = hole_leak(area, fluid)
        self.add_failure_mode(name, failure_rate, fluid, q_std, N)
        # Blowout for soft gasket
        if gasket_type == &#39;soft&#39;:
            name = f&#39;Flange soft gasket blowout: {pipe}&#39;
            failure_rate = table[&#39;Blowout&#39;]
            area = blowout_area or pipe.area
            q_std = hole_leak(area, fluid)
            if q_std_rupture is not None:
                # Blowout flow cannot be greater than rupture flow
                q_std = min(q_std, q_std_rupture)
            self.add_failure_mode(name, failure_rate, fluid, q_std, N)
        # Rupture
        name = f&#39;Flange {gasket_type} gasket rupture: {pipe}&#39;
        failure_rate = table[&#39;Rupture&#39;]
        if q_std_rupture is not None:
            q_std = q_std_rupture
        else:
            area = pipe.area
            q_std = hole_leak(area, fluid)
        self.add_failure_mode(name, failure_rate, fluid, q_std, N)

    def add_valve_failure(self, pipe, fluid, q_std_rupture=None, N=1):
        &#34;&#34;&#34;Add valve leak and rupture failure modes to leaks dict.

        Store failure rate, flow rate and expected time duration of
        the event for transfer line failure. Based on FESHM 4240.
        Failure modes are analyzed by `Volume.odh` method.

        Parameters
        ----------
        pipe : heat_transfer.Pipe
            Pipe/tube upstream the valve.
        fluid : heat_transfer.ThermState
            Thermodynamic state of the fluid stored in the source.
        q_std_rupture : ureg.Quantity, [length]^3/[time]
            Standard volumetric flow rate for flange rupture.
        N : int
            Number of valves
        &#34;&#34;&#34;
        table = TABLE_2[&#39;Valve, pneumatic&#39;]
        # Leak case
        name = f&#39;Valve leak: {pipe}&#39;
        failure_rate = table[&#39;External leak&#39;]
        # Using area from flange leak for consistency
        area = TABLE_2[&#39;Flange, soft gasket&#39;][&#39;Leak&#39;][&#39;Area&#39;]
        q_std = hole_leak(area, fluid)
        self.add_failure_mode(name, failure_rate, fluid, q_std, N)
        # Rupture
        name = f&#39;Valve rupture: {pipe}&#39;
        failure_rate = table[&#39;Rupture&#39;]
        if q_std_rupture is not None:
            q_std = q_std_rupture
        else:
            area = pipe.area
            q_std = hole_leak(area, fluid)
        self.add_failure_mode(name, failure_rate, fluid, q_std, N)

    def add_line_failure(self, pipe, fluid, *, N_welds, N_reinforced, N_soft, N_valves,
                         q_std_rupture=None, blowout_area=None):
        &#34;&#34;&#34;Add leaks for pipe, weld, flange, and valve failures.

        Store failure rate, flow rate and expected time duration of
        the event for pipe, weld, flange, and valve failures. Based on
        FESHM 4240. Failure modes are analyzed by `Volume.odh` method.

        Parameters
        ----------
        pipe : heat_transfer.Pipe
            Pipe/tube upstream the valve.
        fluid : heat_transfer.ThermState
            Thermodynamic state of the fluid stored in the source.
        N_welds : int
            Number of welds on the line.
        N_reinforced : int
            Number of flanges with reinforced, preformed or metal gaskets on the line.
        N_soft : int
            Number of flanges with soft gaskets on the line.
        N_valves : int
            Number of valves on the line.
        q_std_rupture : ureg.Quantity, [length]^3/[time]
            Standard volumetric flow rate for flange rupture.
        blowout_area : Quantity [length^2]
            Leak area in case of the soft gasket blowout. Not applicable for reinforced gaskets.
        &#34;&#34;&#34;
        if N_welds &gt; 0:
            self.add_pipe_failure(pipe, fluid, q_std_rupture, N_welds)
        if N_reinforced &gt; 0:
            self.add_flange_failure(pipe, fluid, q_std_rupture, N=N_reinforced, gasket_type=&#39;reinforced&#39;)
        if N_soft &gt; 0:
            self.add_flange_failure(pipe, fluid, q_std_rupture, N=N_soft, gasket_type=&#39;soft&#39;, blowout_area=blowout_area)
        if N_valves &gt; 0:
            self.add_valve_failure(pipe, fluid, q_std_rupture, N=N_valves)

    # def transfer_line_failure(self, pipe, fluid, q_std_rupture=None, N=1):
    #     &#34;&#34;&#34;Add transfer line failure to leaks dict.

    #     For a given tube calculate leak parameters as following:
    #     - failure rate
    #     - standard volumetric flow
    #     - duration of the release
    #     - number of possible similar events
    #     for all failure modes for transfer line listed in Table 1 of
    #     FESHM 4240. Note that Rationale for Table 1: “Fermilab Equipment
    #     Failure Rate Estimates” clearly states that only bayonet failures
    #     are considered for these failure modes. Therefore only bayonet leak and
    #     blowout (rupture) are considered. Leak area is not defined in
    #     FESHM 4240 and is defined globally as `TRANSFER_LINE_LEAK_AREA`.

    #     Failure modes are analyzed by `Volume.odh` method.

    #     Parameters
    #     ----------
    #     pipe : piping.PipingElement
    #     fluid : cp_wrapper.ThermState
    #         Thermodynamic state of the fluid stored in the source.
    #     q_std_rupture : ureg.Quantity {length: 3, time: -1}
    #         Standard volumetric flow rate for fluid line rupture.
    #     N : int
    #         Number of bayonets/soft seals on the transfer line.
    #     &#34;&#34;&#34;
    #     # TODO This should be replaced by flange failure at some point
    #     # Leak case
    #     name = f&#39;Fluid line gasket leak: {pipe}&#39;
    #     failure_rate = TABLE_1[&#39;Fluid line&#39;][&#39;Leak&#39;]
    #     area = TRANSFER_LINE_LEAK_AREA
    #     q_std = hole_leak(area, fluid)
    #     self.add_failure_mode(name, failure_rate, q_std, N)
    #     # Rupture case
    #     name = f&#39;Fluid line gasket rupture: {pipe}&#39;
    #     failure_rate = TABLE_1[&#39;Fluid line&#39;][&#39;Rupture&#39;]
    #     if q_std_rupture is not None:
    #         q_std = q_std_rupture
    #     else:
    #         area = pipe.area
    #         q_std = hole_leak(area, fluid)
    #     self.add_failure_mode(name, failure_rate, q_std, N)

    def add_pressure_vessel_failure(self, relief_area=None):
        &#34;&#34;&#34;Add pressure vessel failure to leaks dict.

        Store failure rate, flow rate and expected time duration of
        the event for transfer line failure. Based on FESHM 4240.
        Failure modes are analyzed by `Volume.odh` method.

        Parameters
        ----------
        relief_area : ureg.Quantity, [length]^2
            Vacuum jacket relief area if the vessel has one, None otherwise.
        &#34;&#34;&#34;
        # Leak case
        name = &#39;Pressure vessel leak&#39;
        area = TABLE_2[&#39;Vessel, pressure&#39;][&#39;Small leak&#39;][&#39;Area&#39;]
        failure_rate = TABLE_2[&#39;Vessel, pressure&#39;][&#39;Small leak&#39;][&#39;Failure rate&#39;]
        q_std = hole_leak(area, self.fluid)
        self.add_failure_mode(name, failure_rate, self.fluid, q_std, 1)

        # Rupture case
        name = &#39;Pressure vessel rupture&#39;
        if relief_area is None:
            # No vacuum jacket on the vessel
            area = 1000 * ureg.mm**2  # Equal to large leak of a pipe
        else:
            area = relief_area
        failure_rate = TABLE_2[&#39;Vessel, pressure&#39;][&#39;Failure&#39;]
        q_std = hole_leak(area, self.fluid)
        self.add_failure_mode(name, failure_rate, self.fluid, q_std, 1)

    def add_const_leak(self, name, fluid, q_std, N=1):
        &#34;&#34;&#34;Add constant leak to leaks dict.

        Store flow rate and expected time duration of the
        failure event for general failure mode.
        Failure modes are analyzed by `Volume.odh` method.

        Parameters
        ----------
        name : str
            Name of the failure mode
        fluid : ThermState
            Thermodynamic state of the fluid at the leak location.
        q_std : ureg.Quantity, [length**3/time]
            Standard volumetric flow rate.
        N : int
            Number of leaks.
        &#34;&#34;&#34;
        if not fluid:
            fluid = self.fluid
        N_events = N * self.N
        tau_event = self.volume / q_std
        self.leaks.append(ConstLeak(name, fluid, q_std*N_events, tau_event))

    def add_failure_mode(self, name, failure_rate, fluid, q_std, N=1):
        &#34;&#34;&#34;Add general failure mode to leaks dict.

        Store failure rate, flow rate and expected time duration of the
        failure event for general failure mode.
        Failure modes are analyzed by `Volume.odh` method.

        Parameters
        ----------
        name : str
            Name of the failure mode
        failure rate : ureg.Quantity, 1/[time]
            Failure rate of the failure mode,
            i.e. how often the failure occurs
        fluid : ThermState
            Fluid state at the release location.
        q_std : ureg.Quantity, [length]^3/[time]
            Standard volumetric flow rate.
        N : int
            Number of similar failure modes.
        &#34;&#34;&#34;
        N_events = N * self.N
        tau = self.volume/q_std
        total_failure_rate = N_events*failure_rate
        total_failure_rate.ito(1/ureg.hr)
        # self.leaks.append((name, total_failure_rate, q_std, tau.to(ureg.min),
        #                    N_events))
        self.leaks.append(Leak(name, total_failure_rate, fluid, q_std,
                               tau.to(ureg.min), N_events))

    @staticmethod
    def combine(name, fluid, sources, N=1, PFD_isol_valve=1):
        &#34;&#34;&#34;Combine several ODH sources sharing volume.

        Can be used for failure modes affecting several sources in parallel.

        Parameters
        ----------
        name : str
            Name of the new combined source.
        fluid : heat_transfer.ThermState
            Thermodynamic state of the fluid stored in the source.
        sources : list of Source
            Sources connected together.
        N : int
            Number of the sources if several similar sources exist,
            e.g. gas bottles.
        PFD_isol_valve : float
            Probability of failure on demand of source isolation valve.
            If no isolation valve will trigger on ODH alarm, the probability
            is 1 (default).

        Returns
        -------
        Source
            Combined source of inert gas.
        &#34;&#34;&#34;
        if not all([source.fluid.name == fluid.name for source in sources]):
            ODHError(&#39;All volumes should contain the same fluid.&#39;)
            return None
        if sources[0].fluid.name != fluid.name:
            ODHError(&#39;New source should have the same fluid as combined.&#39;)
            return None
        volume_NTP = sum([source.N*source.volume for source in sources])
        fluid_NTP = ThermState(fluid.name, P=P_NTP, T=T_NTP)
        phys_volume = volume_NTP*fluid_NTP.Dmass / fluid.Dmass
        return Source(name, fluid, phys_volume, N=N, PFD_isol_valve=PFD_isol_valve)

    def __repr__(self):
        return f&#39;Source({self.name!r}, {self.fluid!r}, {self.volume!r}, N={int(self.N)}, PFD_isol_valve={float(self.PFD_isol_valve)})&#39;

    def __str__(self):
        return (f&#39;{self.name}, &#39;
            f&#39;{self.volume:,.0f~} &#39;
            f&#39;of {self.fluid.name}&#39;)

    def print_leaks(self):
        &#34;&#34;&#34;Print information on the leaks defined for the source.&#34;&#34;&#34;
        print(f&#39;Printing leaks for {self}&#39;)
        print()
        for leak in self.leaks:
            print(leak.name)
            # TODO This will break for constant leak
            print(f&#39;Total failure rate: {leak.failure_rate:.3g~}&#39;)
            print(f&#39;Leak rate: {leak.q_std:.3g~}&#39;)
            print(f&#39;Event duration: {leak.tau:.3g~}&#39;)
            print(f&#39;Number of events: {leak.N_events}&#39;)
            print()</code></pre>
</details>
<div class="desc"><p>Source of inert gas</p>
<p>Define the possible source of inert gas.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>name</code></strong> :&ensp;<code>str</code></dt>
<dd>Name of the source.</dd>
<dt><strong><code>fluid</code></strong> :&ensp;<code>heat_transfer.ThermState</code></dt>
<dd>Thermodynamic state of the fluid stored in the source.</dd>
<dt><strong><code>liquid_volume</code></strong> :&ensp;<code>ureg.Quantity, [length]^3</code></dt>
<dd>Liquid volume of the source.</dd>
<dt><strong><code>volume</code></strong> :&ensp;<code>ureg.Quantity, [length]^3</code></dt>
<dd>Standard volume of the fluid contained in the source.</dd>
<dt><strong><code>N</code></strong> :&ensp;<code>int</code></dt>
<dd>Number of the sources if several similar sources exist,
e.g. gas bottles.</dd>
<dt><strong><code>PFD_isol_valve</code></strong> :&ensp;<code>float</code></dt>
<dd>Probability of failure on demand of source isolation valve.
If no isolation valve will trigger on ODH alarm, the probability
is 1 (default).</dd>
</dl></div>
<h3>Static methods</h3>
<dl>
<dt id="CryoToolBox.odh.Source.combine"><code class="name flex">
<span>def <span class="ident">combine</span></span>(<span>name, fluid, sources, N=1, PFD_isol_valve=1)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def combine(name, fluid, sources, N=1, PFD_isol_valve=1):
    &#34;&#34;&#34;Combine several ODH sources sharing volume.

    Can be used for failure modes affecting several sources in parallel.

    Parameters
    ----------
    name : str
        Name of the new combined source.
    fluid : heat_transfer.ThermState
        Thermodynamic state of the fluid stored in the source.
    sources : list of Source
        Sources connected together.
    N : int
        Number of the sources if several similar sources exist,
        e.g. gas bottles.
    PFD_isol_valve : float
        Probability of failure on demand of source isolation valve.
        If no isolation valve will trigger on ODH alarm, the probability
        is 1 (default).

    Returns
    -------
    Source
        Combined source of inert gas.
    &#34;&#34;&#34;
    if not all([source.fluid.name == fluid.name for source in sources]):
        ODHError(&#39;All volumes should contain the same fluid.&#39;)
        return None
    if sources[0].fluid.name != fluid.name:
        ODHError(&#39;New source should have the same fluid as combined.&#39;)
        return None
    volume_NTP = sum([source.N*source.volume for source in sources])
    fluid_NTP = ThermState(fluid.name, P=P_NTP, T=T_NTP)
    phys_volume = volume_NTP*fluid_NTP.Dmass / fluid.Dmass
    return Source(name, fluid, phys_volume, N=N, PFD_isol_valve=PFD_isol_valve)</code></pre>
</details>
<div class="desc"><p>Combine several ODH sources sharing volume.</p>
<p>Can be used for failure modes affecting several sources in parallel.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>name</code></strong> :&ensp;<code>str</code></dt>
<dd>Name of the new combined source.</dd>
<dt><strong><code>fluid</code></strong> :&ensp;<code>heat_transfer.ThermState</code></dt>
<dd>Thermodynamic state of the fluid stored in the source.</dd>
<dt><strong><code>sources</code></strong> :&ensp;<code>list</code> of <code><a title="CryoToolBox.odh.Source" href="#CryoToolBox.odh.Source">Source</a></code></dt>
<dd>Sources connected together.</dd>
<dt><strong><code>N</code></strong> :&ensp;<code>int</code></dt>
<dd>Number of the sources if several similar sources exist,
e.g. gas bottles.</dd>
<dt><strong><code>PFD_isol_valve</code></strong> :&ensp;<code>float</code></dt>
<dd>Probability of failure on demand of source isolation valve.
If no isolation valve will trigger on ODH alarm, the probability
is 1 (default).</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code><a title="CryoToolBox.odh.Source" href="#CryoToolBox.odh.Source">Source</a></code></dt>
<dd>Combined source of inert gas.</dd>
</dl></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="CryoToolBox.odh.Source.add_const_leak"><code class="name flex">
<span>def <span class="ident">add_const_leak</span></span>(<span>self, name, fluid, q_std, N=1)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_const_leak(self, name, fluid, q_std, N=1):
    &#34;&#34;&#34;Add constant leak to leaks dict.

    Store flow rate and expected time duration of the
    failure event for general failure mode.
    Failure modes are analyzed by `Volume.odh` method.

    Parameters
    ----------
    name : str
        Name of the failure mode
    fluid : ThermState
        Thermodynamic state of the fluid at the leak location.
    q_std : ureg.Quantity, [length**3/time]
        Standard volumetric flow rate.
    N : int
        Number of leaks.
    &#34;&#34;&#34;
    if not fluid:
        fluid = self.fluid
    N_events = N * self.N
    tau_event = self.volume / q_std
    self.leaks.append(ConstLeak(name, fluid, q_std*N_events, tau_event))</code></pre>
</details>
<div class="desc"><p>Add constant leak to leaks dict.</p>
<p>Store flow rate and expected time duration of the
failure event for general failure mode.
Failure modes are analyzed by <code><a title="CryoToolBox.odh.Volume.odh" href="#CryoToolBox.odh.Volume.odh">Volume.odh()</a></code> method.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>name</code></strong> :&ensp;<code>str</code></dt>
<dd>Name of the failure mode</dd>
<dt><strong><code>fluid</code></strong> :&ensp;<code>ThermState</code></dt>
<dd>Thermodynamic state of the fluid at the leak location.</dd>
<dt><strong><code>q_std</code></strong> :&ensp;<code>ureg.Quantity, [length**3/time]</code></dt>
<dd>Standard volumetric flow rate.</dd>
<dt><strong><code>N</code></strong> :&ensp;<code>int</code></dt>
<dd>Number of leaks.</dd>
</dl></div>
</dd>
<dt id="CryoToolBox.odh.Source.add_dewar_insulation_failure"><code class="name flex">
<span>def <span class="ident">add_dewar_insulation_failure</span></span>(<span>self, q_std)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_dewar_insulation_failure(self, q_std):
    &#34;&#34;&#34;Add dewar insulation failure to leaks dict.

    Store failure rate, flow rate and expected time duration of the
    failure event for the dewar insulation failure. Based on FESHM4240.
    Failure modes are analyzed by `Volume.odh` method.

    Parameters
    ----------
    q_std : ureg.Quantity, [length]^3/[time]
        Standard volumetric flow rate of the relief for the case of
        dewar insulation failure.
    &#34;&#34;&#34;
    failure_rate = TABLE_1[&#39;Dewar&#39;][&#39;Loss of vacuum&#39;]
    self.add_failure_mode(&#39;Dewar insulation failure&#39;, failure_rate,
                          self.fluid, q_std, 1)</code></pre>
</details>
<div class="desc"><p>Add dewar insulation failure to leaks dict.</p>
<p>Store failure rate, flow rate and expected time duration of the
failure event for the dewar insulation failure. Based on FESHM4240.
Failure modes are analyzed by <code><a title="CryoToolBox.odh.Volume.odh" href="#CryoToolBox.odh.Volume.odh">Volume.odh()</a></code> method.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>q_std</code></strong> :&ensp;<code>ureg.Quantity, [length]^3/[time]</code></dt>
<dd>Standard volumetric flow rate of the relief for the case of
dewar insulation failure.</dd>
</dl></div>
</dd>
<dt id="CryoToolBox.odh.Source.add_failure_mode"><code class="name flex">
<span>def <span class="ident">add_failure_mode</span></span>(<span>self, name, failure_rate, fluid, q_std, N=1)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_failure_mode(self, name, failure_rate, fluid, q_std, N=1):
    &#34;&#34;&#34;Add general failure mode to leaks dict.

    Store failure rate, flow rate and expected time duration of the
    failure event for general failure mode.
    Failure modes are analyzed by `Volume.odh` method.

    Parameters
    ----------
    name : str
        Name of the failure mode
    failure rate : ureg.Quantity, 1/[time]
        Failure rate of the failure mode,
        i.e. how often the failure occurs
    fluid : ThermState
        Fluid state at the release location.
    q_std : ureg.Quantity, [length]^3/[time]
        Standard volumetric flow rate.
    N : int
        Number of similar failure modes.
    &#34;&#34;&#34;
    N_events = N * self.N
    tau = self.volume/q_std
    total_failure_rate = N_events*failure_rate
    total_failure_rate.ito(1/ureg.hr)
    # self.leaks.append((name, total_failure_rate, q_std, tau.to(ureg.min),
    #                    N_events))
    self.leaks.append(Leak(name, total_failure_rate, fluid, q_std,
                           tau.to(ureg.min), N_events))</code></pre>
</details>
<div class="desc"><p>Add general failure mode to leaks dict.</p>
<p>Store failure rate, flow rate and expected time duration of the
failure event for general failure mode.
Failure modes are analyzed by <code><a title="CryoToolBox.odh.Volume.odh" href="#CryoToolBox.odh.Volume.odh">Volume.odh()</a></code> method.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>name</code></strong> :&ensp;<code>str</code></dt>
<dd>Name of the failure mode</dd>
<dt>failure rate : ureg.Quantity, 1/[time]</dt>
<dt>Failure rate of the failure mode,</dt>
<dt>i.e. how often the failure occurs</dt>
<dt><strong><code>fluid</code></strong> :&ensp;<code>ThermState</code></dt>
<dd>Fluid state at the release location.</dd>
<dt><strong><code>q_std</code></strong> :&ensp;<code>ureg.Quantity, [length]^3/[time]</code></dt>
<dd>Standard volumetric flow rate.</dd>
<dt><strong><code>N</code></strong> :&ensp;<code>int</code></dt>
<dd>Number of similar failure modes.</dd>
</dl></div>
</dd>
<dt id="CryoToolBox.odh.Source.add_flange_failure"><code class="name flex">
<span>def <span class="ident">add_flange_failure</span></span>(<span>self, pipe, fluid, q_std_rupture=None, N=1, gasket_type='reinforced', blowout_area=None)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_flange_failure(self, pipe, fluid, q_std_rupture=None, N=1,
                       gasket_type=&#39;reinforced&#39;, blowout_area=None):
    &#34;&#34;&#34;Add reinforced or preformed gasket flange failure
    to leaks dict.

    Store failure rate, flow rate and expected time duration of
    the event for transfer line failure. Based on FESHM 4240.
    Failure modes are analyzed by `Volume.odh` method.

    Parameters
    ----------
    pipe : heat_transfer.Pipe
    fluid : heat_transfer.ThermState
        Thermodynamic state of the fluid stored in the source.
    q_std_rupture : ureg.Quantity, [length]^3/[time]
        Standard volumetric flow rate for flange rupture.
    N : int
        Number of reinforced seal connections on the pipe.
    gasket_type : str
        Type of the gasket in the flange, &#39;soft&#39; or &#39;reinforced&#39;.
    blowout_area : Quantity [length^2]
        Leak area in case of the soft gasket blowout. Not applicable for reinforced gaskets.
    &#34;&#34;&#34;
    # TODO Make leak and rupture areas adjustable, add info to docstring
    if gasket_type == &#39;reinforced&#39;:
        table = TABLE_2[&#39;Flange, reinforced gasket&#39;]
    if gasket_type == &#39;soft&#39;:
        table = TABLE_2[&#39;Flange, soft gasket&#39;]
    # Leak case
    name = f&#39;Flange {gasket_type} gasket leak: {pipe}&#39;
    failure_rate = table[&#39;Leak&#39;][&#39;Failure rate&#39;]
    area = table[&#39;Leak&#39;][&#39;Area&#39;]
    q_std = hole_leak(area, fluid)
    self.add_failure_mode(name, failure_rate, fluid, q_std, N)
    # Blowout for soft gasket
    if gasket_type == &#39;soft&#39;:
        name = f&#39;Flange soft gasket blowout: {pipe}&#39;
        failure_rate = table[&#39;Blowout&#39;]
        area = blowout_area or pipe.area
        q_std = hole_leak(area, fluid)
        if q_std_rupture is not None:
            # Blowout flow cannot be greater than rupture flow
            q_std = min(q_std, q_std_rupture)
        self.add_failure_mode(name, failure_rate, fluid, q_std, N)
    # Rupture
    name = f&#39;Flange {gasket_type} gasket rupture: {pipe}&#39;
    failure_rate = table[&#39;Rupture&#39;]
    if q_std_rupture is not None:
        q_std = q_std_rupture
    else:
        area = pipe.area
        q_std = hole_leak(area, fluid)
    self.add_failure_mode(name, failure_rate, fluid, q_std, N)</code></pre>
</details>
<div class="desc"><p>Add reinforced or preformed gasket flange failure
to leaks dict.</p>
<p>Store failure rate, flow rate and expected time duration of
the event for transfer line failure. Based on FESHM 4240.
Failure modes are analyzed by <code><a title="CryoToolBox.odh.Volume.odh" href="#CryoToolBox.odh.Volume.odh">Volume.odh()</a></code> method.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>pipe</code></strong> :&ensp;<code>heat_transfer.Pipe</code></dt>
<dd>&nbsp;</dd>
<dt><strong><code>fluid</code></strong> :&ensp;<code>heat_transfer.ThermState</code></dt>
<dd>Thermodynamic state of the fluid stored in the source.</dd>
<dt><strong><code>q_std_rupture</code></strong> :&ensp;<code>ureg.Quantity, [length]^3/[time]</code></dt>
<dd>Standard volumetric flow rate for flange rupture.</dd>
<dt><strong><code>N</code></strong> :&ensp;<code>int</code></dt>
<dd>Number of reinforced seal connections on the pipe.</dd>
<dt><strong><code>gasket_type</code></strong> :&ensp;<code>str</code></dt>
<dd>Type of the gasket in the flange, 'soft' or 'reinforced'.</dd>
<dt><strong><code>blowout_area</code></strong> :&ensp;<code>Quantity [length^2]</code></dt>
<dd>Leak area in case of the soft gasket blowout. Not applicable for reinforced gaskets.</dd>
</dl></div>
</dd>
<dt id="CryoToolBox.odh.Source.add_line_failure"><code class="name flex">
<span>def <span class="ident">add_line_failure</span></span>(<span>self,<br>pipe,<br>fluid,<br>*,<br>N_welds,<br>N_reinforced,<br>N_soft,<br>N_valves,<br>q_std_rupture=None,<br>blowout_area=None)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_line_failure(self, pipe, fluid, *, N_welds, N_reinforced, N_soft, N_valves,
                     q_std_rupture=None, blowout_area=None):
    &#34;&#34;&#34;Add leaks for pipe, weld, flange, and valve failures.

    Store failure rate, flow rate and expected time duration of
    the event for pipe, weld, flange, and valve failures. Based on
    FESHM 4240. Failure modes are analyzed by `Volume.odh` method.

    Parameters
    ----------
    pipe : heat_transfer.Pipe
        Pipe/tube upstream the valve.
    fluid : heat_transfer.ThermState
        Thermodynamic state of the fluid stored in the source.
    N_welds : int
        Number of welds on the line.
    N_reinforced : int
        Number of flanges with reinforced, preformed or metal gaskets on the line.
    N_soft : int
        Number of flanges with soft gaskets on the line.
    N_valves : int
        Number of valves on the line.
    q_std_rupture : ureg.Quantity, [length]^3/[time]
        Standard volumetric flow rate for flange rupture.
    blowout_area : Quantity [length^2]
        Leak area in case of the soft gasket blowout. Not applicable for reinforced gaskets.
    &#34;&#34;&#34;
    if N_welds &gt; 0:
        self.add_pipe_failure(pipe, fluid, q_std_rupture, N_welds)
    if N_reinforced &gt; 0:
        self.add_flange_failure(pipe, fluid, q_std_rupture, N=N_reinforced, gasket_type=&#39;reinforced&#39;)
    if N_soft &gt; 0:
        self.add_flange_failure(pipe, fluid, q_std_rupture, N=N_soft, gasket_type=&#39;soft&#39;, blowout_area=blowout_area)
    if N_valves &gt; 0:
        self.add_valve_failure(pipe, fluid, q_std_rupture, N=N_valves)</code></pre>
</details>
<div class="desc"><p>Add leaks for pipe, weld, flange, and valve failures.</p>
<p>Store failure rate, flow rate and expected time duration of
the event for pipe, weld, flange, and valve failures. Based on
FESHM 4240. Failure modes are analyzed by <code><a title="CryoToolBox.odh.Volume.odh" href="#CryoToolBox.odh.Volume.odh">Volume.odh()</a></code> method.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>pipe</code></strong> :&ensp;<code>heat_transfer.Pipe</code></dt>
<dd>Pipe/tube upstream the valve.</dd>
<dt><strong><code>fluid</code></strong> :&ensp;<code>heat_transfer.ThermState</code></dt>
<dd>Thermodynamic state of the fluid stored in the source.</dd>
<dt><strong><code>N_welds</code></strong> :&ensp;<code>int</code></dt>
<dd>Number of welds on the line.</dd>
<dt><strong><code>N_reinforced</code></strong> :&ensp;<code>int</code></dt>
<dd>Number of flanges with reinforced, preformed or metal gaskets on the line.</dd>
<dt><strong><code>N_soft</code></strong> :&ensp;<code>int</code></dt>
<dd>Number of flanges with soft gaskets on the line.</dd>
<dt><strong><code>N_valves</code></strong> :&ensp;<code>int</code></dt>
<dd>Number of valves on the line.</dd>
<dt><strong><code>q_std_rupture</code></strong> :&ensp;<code>ureg.Quantity, [length]^3/[time]</code></dt>
<dd>Standard volumetric flow rate for flange rupture.</dd>
<dt><strong><code>blowout_area</code></strong> :&ensp;<code>Quantity [length^2]</code></dt>
<dd>Leak area in case of the soft gasket blowout. Not applicable for reinforced gaskets.</dd>
</dl></div>
</dd>
<dt id="CryoToolBox.odh.Source.add_pipe_failure"><code class="name flex">
<span>def <span class="ident">add_pipe_failure</span></span>(<span>self, tube, fluid, q_std_rupture=None, N_welds=1)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_pipe_failure(self, tube, fluid, q_std_rupture=None, N_welds=1):
    &#34;&#34;&#34;Add pipe failure to the leaks dict.

    For a given tube calculate leak parameters as following:
    - failure rate
    - standard volumetric flow
    - duration of the release
    - number of possible similar events
    for all failure modes for piping and welds listed in Table 2 of
    FESHM 4240.

    Failure modes are analyzed by `Volume.odh` method.

    Parameters
    ----------
    tube : heat_transfer.piping.Tube
    fluid : heat_transfer.ThermState
        Thermodynamic state of the fluid for the release.
    q_std_rupture : ureg.Quantity, [length]^3/[time]
        Standard volumetric flow rate for pipe rupture.
    N_welds : int
        Number of welds on the tube.
    &#34;&#34;&#34;
    # Failure rate coefficients; Piping failure rate is per unit of length,
    # weld is dependent on number of welds, pipe OD and wall thickness
    failure_rate_coeff = {&#39;Piping&#39;: (tube.L, 1),
                          &#39;Pipe weld&#39;: (tube.OD / tube.wall,
                                        N_welds)}
    # Piping and weld leaks as per Table 2
    for cause, fr_coefs in failure_rate_coeff.items():
        for mode in TABLE_2[cause].keys():
            if tube.D &gt; 2 or mode != &#39;Large leak&#39;:  # Large leak only for D &gt; 2&#34;
                name = f&#39;{cause} {mode.lower()}: {tube}&#39;
                fr_coef, N_events = fr_coefs
                if fr_coef.magnitude == 0:
                    raise ODHError(&#39;Failure rate should not be 0 &#39;
                                   f&#39;{cause} {mode}.&#39;)
                if N_events == 0:
                    continue
                if mode == &#39;Rupture&#39;:
                    failure_rate = fr_coef * TABLE_2[cause][mode]
                    if q_std_rupture is not None:
                        q_std = q_std_rupture
                    else:
                        area = tube.area
                        q_std = hole_leak(area, fluid)
                else:
                    failure_rate = fr_coef * \
                        TABLE_2[cause][mode][&#39;Failure rate&#39;]
                    area = TABLE_2[cause][mode][&#39;Area&#39;]
                    if area &gt; tube.area:
                        ODHError(&#39;Leak area cannot be larger&#39;
                                 &#39; than pipe area.&#39;)
                    q_std = hole_leak(area, fluid)
                self.add_failure_mode(name, failure_rate, fluid, q_std,
                                      N_events)</code></pre>
</details>
<div class="desc"><p>Add pipe failure to the leaks dict.</p>
<p>For a given tube calculate leak parameters as following:
- failure rate
- standard volumetric flow
- duration of the release
- number of possible similar events
for all failure modes for piping and welds listed in Table 2 of
FESHM 4240.</p>
<p>Failure modes are analyzed by <code><a title="CryoToolBox.odh.Volume.odh" href="#CryoToolBox.odh.Volume.odh">Volume.odh()</a></code> method.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>tube</code></strong> :&ensp;<code>heat_transfer.piping.Tube</code></dt>
<dd>&nbsp;</dd>
<dt><strong><code>fluid</code></strong> :&ensp;<code>heat_transfer.ThermState</code></dt>
<dd>Thermodynamic state of the fluid for the release.</dd>
<dt><strong><code>q_std_rupture</code></strong> :&ensp;<code>ureg.Quantity, [length]^3/[time]</code></dt>
<dd>Standard volumetric flow rate for pipe rupture.</dd>
<dt><strong><code>N_welds</code></strong> :&ensp;<code>int</code></dt>
<dd>Number of welds on the tube.</dd>
</dl></div>
</dd>
<dt id="CryoToolBox.odh.Source.add_pressure_vessel_failure"><code class="name flex">
<span>def <span class="ident">add_pressure_vessel_failure</span></span>(<span>self, relief_area=None)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_pressure_vessel_failure(self, relief_area=None):
    &#34;&#34;&#34;Add pressure vessel failure to leaks dict.

    Store failure rate, flow rate and expected time duration of
    the event for transfer line failure. Based on FESHM 4240.
    Failure modes are analyzed by `Volume.odh` method.

    Parameters
    ----------
    relief_area : ureg.Quantity, [length]^2
        Vacuum jacket relief area if the vessel has one, None otherwise.
    &#34;&#34;&#34;
    # Leak case
    name = &#39;Pressure vessel leak&#39;
    area = TABLE_2[&#39;Vessel, pressure&#39;][&#39;Small leak&#39;][&#39;Area&#39;]
    failure_rate = TABLE_2[&#39;Vessel, pressure&#39;][&#39;Small leak&#39;][&#39;Failure rate&#39;]
    q_std = hole_leak(area, self.fluid)
    self.add_failure_mode(name, failure_rate, self.fluid, q_std, 1)

    # Rupture case
    name = &#39;Pressure vessel rupture&#39;
    if relief_area is None:
        # No vacuum jacket on the vessel
        area = 1000 * ureg.mm**2  # Equal to large leak of a pipe
    else:
        area = relief_area
    failure_rate = TABLE_2[&#39;Vessel, pressure&#39;][&#39;Failure&#39;]
    q_std = hole_leak(area, self.fluid)
    self.add_failure_mode(name, failure_rate, self.fluid, q_std, 1)</code></pre>
</details>
<div class="desc"><p>Add pressure vessel failure to leaks dict.</p>
<p>Store failure rate, flow rate and expected time duration of
the event for transfer line failure. Based on FESHM 4240.
Failure modes are analyzed by <code><a title="CryoToolBox.odh.Volume.odh" href="#CryoToolBox.odh.Volume.odh">Volume.odh()</a></code> method.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>relief_area</code></strong> :&ensp;<code>ureg.Quantity, [length]^2</code></dt>
<dd>Vacuum jacket relief area if the vessel has one, None otherwise.</dd>
</dl></div>
</dd>
<dt id="CryoToolBox.odh.Source.add_valve_failure"><code class="name flex">
<span>def <span class="ident">add_valve_failure</span></span>(<span>self, pipe, fluid, q_std_rupture=None, N=1)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def add_valve_failure(self, pipe, fluid, q_std_rupture=None, N=1):
    &#34;&#34;&#34;Add valve leak and rupture failure modes to leaks dict.

    Store failure rate, flow rate and expected time duration of
    the event for transfer line failure. Based on FESHM 4240.
    Failure modes are analyzed by `Volume.odh` method.

    Parameters
    ----------
    pipe : heat_transfer.Pipe
        Pipe/tube upstream the valve.
    fluid : heat_transfer.ThermState
        Thermodynamic state of the fluid stored in the source.
    q_std_rupture : ureg.Quantity, [length]^3/[time]
        Standard volumetric flow rate for flange rupture.
    N : int
        Number of valves
    &#34;&#34;&#34;
    table = TABLE_2[&#39;Valve, pneumatic&#39;]
    # Leak case
    name = f&#39;Valve leak: {pipe}&#39;
    failure_rate = table[&#39;External leak&#39;]
    # Using area from flange leak for consistency
    area = TABLE_2[&#39;Flange, soft gasket&#39;][&#39;Leak&#39;][&#39;Area&#39;]
    q_std = hole_leak(area, fluid)
    self.add_failure_mode(name, failure_rate, fluid, q_std, N)
    # Rupture
    name = f&#39;Valve rupture: {pipe}&#39;
    failure_rate = table[&#39;Rupture&#39;]
    if q_std_rupture is not None:
        q_std = q_std_rupture
    else:
        area = pipe.area
        q_std = hole_leak(area, fluid)
    self.add_failure_mode(name, failure_rate, fluid, q_std, N)</code></pre>
</details>
<div class="desc"><p>Add valve leak and rupture failure modes to leaks dict.</p>
<p>Store failure rate, flow rate and expected time duration of
the event for transfer line failure. Based on FESHM 4240.
Failure modes are analyzed by <code><a title="CryoToolBox.odh.Volume.odh" href="#CryoToolBox.odh.Volume.odh">Volume.odh()</a></code> method.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>pipe</code></strong> :&ensp;<code>heat_transfer.Pipe</code></dt>
<dd>Pipe/tube upstream the valve.</dd>
<dt><strong><code>fluid</code></strong> :&ensp;<code>heat_transfer.ThermState</code></dt>
<dd>Thermodynamic state of the fluid stored in the source.</dd>
<dt><strong><code>q_std_rupture</code></strong> :&ensp;<code>ureg.Quantity, [length]^3/[time]</code></dt>
<dd>Standard volumetric flow rate for flange rupture.</dd>
<dt><strong><code>N</code></strong> :&ensp;<code>int</code></dt>
<dd>Number of valves</dd>
</dl></div>
</dd>
<dt id="CryoToolBox.odh.Source.print_leaks"><code class="name flex">
<span>def <span class="ident">print_leaks</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def print_leaks(self):
    &#34;&#34;&#34;Print information on the leaks defined for the source.&#34;&#34;&#34;
    print(f&#39;Printing leaks for {self}&#39;)
    print()
    for leak in self.leaks:
        print(leak.name)
        # TODO This will break for constant leak
        print(f&#39;Total failure rate: {leak.failure_rate:.3g~}&#39;)
        print(f&#39;Leak rate: {leak.q_std:.3g~}&#39;)
        print(f&#39;Event duration: {leak.tau:.3g~}&#39;)
        print(f&#39;Number of events: {leak.N_events}&#39;)
        print()</code></pre>
</details>
<div class="desc"><p>Print information on the leaks defined for the source.</p></div>
</dd>
</dl>
</dd>
<dt id="CryoToolBox.odh.Volume"><code class="flex name class">
<span>class <span class="ident">Volume</span></span>
<span>(</span><span>name, volume, *, build_vent, build_power)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Volume:
    &#34;&#34;&#34;
    A class to represent a building or a part of a building that is affected by
    inert gas leaks.

    Parameters
    ----------
    name : str
        The name of the volume.
    volume : ureg.Quantity, [length]^3
        The volume of the building or part of the building.

    Attributes
    ----------
    name : str
        The name of the volume.
    volume : ureg.Quantity, [length]^3
        The volume of the building or part of the building.
    vent : BuildVent
        The ventilation system of the building or part of the building.
    power : BuildPower
        The power system of the building or part of the building.

    Methods
    -------
    info()
        Display information on the volume.
    odh(sources, power_outage=False)
        Calculate ODH fatality rate for given `Source`s.
    _fatality_no_power(source, leak, power_outage)
        Calculate fatality rate in the event of power failure.
    _fatality_no_odh(source, leak)
        Calculate fatality rate in the event of ODH system failure.
    _fatality_with_fans(source, leak)
        Calculate fatality rate for any number of fans operational.
    _add_failure_mode(P_event, tau_event, failure_rate, source, leak, Q_fan,
        N_fans, power_outage)
        Add a failure mode.
    _fatality_const_leak(source, leak, power_outage)
        Calculate fatality rates for constant leak case.
    _fatality_prob(O2_conc)
        Calculate fatality probability for given oxygen concentration.
    &#34;&#34;&#34;
    def __init__(self, name, volume, *, build_vent, build_power):
        &#34;&#34;&#34;Define a volume affected by inert gas release from  a `Source`.

        Parameters
        ----------
        name : str
            Name of the volume.
        volume : ureg.Quantity, [length]^3
            Volume of the building or part of the building.
        &#34;&#34;&#34;
        self.name = name
        self.volume = volume.to_base_units()
        self.vent = build_vent
        self.power = build_power

    def info(self):
        &#34;&#34;&#34;
        Display information on the volume.
        &#34;&#34;&#34;
        print(f&#39;{self.name} with affected volume of {self.volume:,.0f~}.&#39;)
        print(self.power.info())
        print(self.vent.info())

    def odh(self, sources, power_outage=False):
        &#34;&#34;&#34;Calculate ODH fatality rate for given `Source`s.

        For each leak of each source ODH conditions are analyzed and
        fatality rates are calculated. The results are collected in
        fail_modes list.

        Parameters
        ----------
        sources : List[Source]
            Sources affecting the volume.
        power_outage : bool
            Shows whether there is a power outage is in effect.
            Default is no outage.

        Returns
        -------
        None
        &#34;&#34;&#34;
        self.fail_modes = []
        for source in sources:
            for leak in source.leaks:
                if not leak._is_const:
                    self._fatality_no_power(source, leak, power_outage)
                    if not power_outage:
                        self._fatality_no_odh(source, leak)
                        self._fatality_with_fans(source, leak)
                else:
                    self._fatality_const_leak(source, leak, power_outage)

    def _fatality_no_power(self, source, leak, power_outage):
        &#34;&#34;&#34;Calculate fatality rate in the event of power failure.

        Source isolation is the only protection for this case. No ventilation
        is available without electric power.

        Parameters
        ----------
        source : Source
        leak : Leak
            Leak failure rate, volumetric flow rate, event duration, and number
            of events.
        power_outage : bool
            Shows whether there is a power outage is in effect.

        Returns
        -------
        None
        &#34;&#34;&#34;
        if power_outage:
            PFD_power = 1
            tau_event = leak.tau
            scenario = &#39;Planned power outage&#39;
        else:
            PFD_power = self.power.pfd
            tau_event = min(leak.tau, self.power.max_outage)
            scenario = &#39;Power failure&#39;
        PFD_isol_valve = source.PFD_isol_valve
        P_event = PFD_power * PFD_isol_valve
        Q_fan = 0 * ureg.ft**3/ureg.min
        self._add_failure_mode(P_event, tau_event, leak.failure_rate, source,
                               leak, Q_fan, 0, power_outage, scenario)

    def _fatality_no_odh(self, source, leak):
        &#34;&#34;&#34;Calculate fatality rate in the event of ODH system failure.

        Power has to be  on for ODH system to fail. Source isolation is
        possible for this event. Only ventilation independent from ODH system
        is available, e.g., HVAC.

        Parameters
        ----------
        source : Source
        leak : Leak
            Leak failure rate, volumetric flow rate, event duration, and number
            of events.

        Returns
        -------
        None
        &#34;&#34;&#34;
        PFD_isol_valve = source.PFD_isol_valve
        P_event = (1-self.power.pfd) * self.vent.PFD_ODH * PFD_isol_valve
        Q_fan = self.vent.const_vent
        tau_event = min(leak.tau, self.vent.Test_period)
        scenario = &#39;ODH system failure&#39;
        self._add_failure_mode(P_event, tau_event, leak.failure_rate, source,
                               leak, Q_fan, 0, False, scenario)

    def _fatality_with_fans(self, source, leak):
        &#34;&#34;&#34;Calculate fatality rate for any number of fans operational.

        Power has to be  on, and ODH system operational. Source isolation is
        possible for this event. Ventilation independent from ODH system,
        e.g., HVAC, is considered for all fans unavailable at the time of
        the event.

        Parameters
        ----------
        source : Source
        leak : Leak
            Leak failure rate, volumetric flow rate, event duration, and number
            of events.

        Returns
        -------
        None
        &#34;&#34;&#34;
        PFD_isol_valve = source.PFD_isol_valve
        # Probability for this group of the events
        P_group = (1-self.power.pfd) * (1-self.vent.PFD_ODH) * PFD_isol_valve
        tau_event = min(leak.tau, self.vent.Test_period)
        for (P_fan, Q_fan, N_fans) in self.vent.fan_flowrates():
            P_event = P_group * P_fan  # Probability of the particular event
            if N_fans == self.vent.N_fans:
                scenario = &#39;Normal operation&#39;
            else:
                scenario = &#39;Fan failure&#39;
            self._add_failure_mode(P_event, tau_event,
                                   leak.failure_rate, source, leak, Q_fan,
                                   N_fans, False, scenario)

    def _add_failure_mode(self, P_event, tau_event, failure_rate, source, leak,
                          Q_fan, N_fans, power_outage, scenario):
        &#34;&#34;&#34;Add a failure mode.

        Parameters
        ----------
        P_event : float
            Probability of a particular state of the system, assuming the leak
            has happened. Alternatively, probability of a constant leak or 1.
        failure_rate : ureg.Quantity, 1/[time]
            Failure rate of the leak. Alternatively, system failure rate for
            a constant leak.
        tau_event : ureg.Quantity, [time]
            Maximum duration of the event.
        source : Source
            Inert gas source.
        leak : Leak
            Leak failure rate, volumetric flow rate, event duration, and number
            of events.
        fluid : ThermState
            Fluid conditions at the release location.
        Q_fan : ureg.Quantity, [length]^3/[time]
            Combined volumetric flow of ODH fans for the event.
        N_fans : int
            Number of fans operational during the event.
        power_outage : bool
            Shows whether there is a power outage is in effect.
        scenario: str
            Name of the response scenario, e.g., power failure, ODH system failure,
            normal operation.

        Returns
        -------
        None
        &#34;&#34;&#34;
        P_i = failure_rate * P_event
        O2_conc = conc_vent(self.volume, leak.q_std, Q_fan, tau_event)
        F_i = self._fatality_prob(O2_conc)
        phi_i = P_i*F_i
        if leak._is_const == True:
            N_events = 1
        else:
            N_events = leak.N_events
        self.fail_modes.append(
            FailureMode(leak.name, source, leak.fluid, phi_i, O2_conc,
                        failure_rate, P_i, F_i, power_outage, leak.q_std,
                        tau_event, Q_fan, N_fans, N_events, leak._is_const,
                        scenario)
        )

    def _fatality_const_leak(self, source, leak, power_outage):
        &#34;&#34;&#34;Calculate fatality rates for constant leak case.

        Calculate fatality rates for the case of ODH system responding and
        fans powered but some of the fans failing on demand.
        See wiki for further explanation.
        Adds calculation results to the fail_modes list.

        Parameters
        ----------
        source : Source
        leak : Leak
            Leak failure rate, volumetric flow rate, event duration, and number
            of events.
        power_outage : bool
            Shows whether there is a power outage is in effect.

        Returns
        -------
        None
        &#34;&#34;&#34;

        PFD_isol_valve = source.PFD_isol_valve
        if power_outage:
            tau_outage = leak.tau
            Q_fan_outage = 0 * ureg.ft**3/ureg.min  # No ventilation without power
            O2_conc_outage = conc_vent(self.volume, leak.q_std, Q_fan_outage, tau_outage)
            if O2_conc_outage &lt; 0.195:
                raise ConstLeakNoVent(f&#39;Constant leak {leak.name} from &#39;
                                    f&#39;{source.name} is not mitigated during &#39;
                                    f&#39;power outage in {self.name}.&#39;)

        # Constant leak and power failure
        failure_rate = self.power.lambda_power
        # Constant leak is assumed to be hazardous only when
        # the isolation valve fails
        P_event = PFD_isol_valve * self.power.backup_pfd
        Q_fan = 0 * ureg.ft**3/ureg.min  # No ventilation without power
        tau_event = min([self.vent.Test_period, self.power.max_outage, leak.tau])
        scenario = &#39;Const leak and power failure&#39;
        self._add_failure_mode(P_event, tau_event, failure_rate,
                               source, leak, Q_fan, 0, False,
                               scenario)

        # Constant leak and ODH system failure
        failure_rate = lambda_ODH
        P_event = 1  # ODH system failure will not trigger isolation valve
        # Event can&#39;t go undetected for longer than the test period
        tau_event = self.vent.Test_period
        scenario = &#39;Const leak and ODH system failure&#39;
        # Ventilation is available on ODH system failure
        self._add_failure_mode(P_event, tau_event, failure_rate,
                               source, leak, self.vent.const_vent, 0, False,
                               scenario)

        # Fan failure
        # If at least 1 fan is down, all fans are considered non-operational
        failure_rate = TABLE_2[&#39;Fan&#39;][&#39;Failure to run&#39;]
        P_event = PFD_isol_valve
        # Event can&#39;t go undetected for longer than the test period
        tau_event = self.vent.Test_period
        scenario = &#39;Const leak and 1 fan failure&#39;
        self._add_failure_mode(P_event, tau_event, failure_rate,
                               source, leak, self.vent.const_vent, 0, False,
                               scenario)

        # Fans operational
        # If fatality is possible with just one fan, raise error
        Q_1fan = max(self.vent.Q_fan, self.vent.const_vent)
        O2_conc_1fan = conc_final(leak.q_std, Q_1fan)
        if O2_conc_1fan &lt; 0.195:
            raise ConstLeakTooBig(&#39;Constant leak reduces O2 concentration to &#39;
                                  f&#39;{O2_conc_1fan:.1%} with {Q_1fan:.3g~} &#39;
                                  f&#39;vent rate: {leak.name}&#39;)

    def _fatality_prob(self, O2_conc):
        &#34;&#34;&#34;Calculate fatality probability for given oxygen concentration.

        The equation is fitted from the FESHM 4240 plot.

        Parameters
        ----------
        O2_conc : float
            Oxygen concentration.

        Returns
        -------
        float
            Fatality rate.
        &#34;&#34;&#34;
        if O2_conc &gt;= 0.18:  # Lowest oxygen concentration above 18%
            Fi = 0
        elif O2_conc &lt;= 0.088:  # 8.8% of oxygen is assumed to be 100% fatal
            Fi = 1
        else:
            # Fi formula, reverse engineered using 8.8% and 18% thresholds
            Fi = 10**(6.5-76*O2_conc)
        return Fi

    @property
    def odh_class(self):
        &#34;&#34;&#34;Calculate ODH class as defined in FESHM 4240.

        Returns
        -------
        int
            ODH class.
        &#34;&#34;&#34;
        if self.phi &lt; 1e-7/ureg.hr:
            return 0
        elif self.phi &lt; 1e-5/ureg.hr:
            return 1
        elif self.phi &lt; 1e-3/ureg.hr:
            return 2
        else:
            # TODO add a custom exception for ODH &gt; 2
            raise ODHError(&#39;ODH fatality rate is too high. Please, check calculations.&#39;)

    @property
    def phi(self):
        return sum((fm.phi for fm in self.fail_modes)).to(1/ureg.hr)

    # def report(self, brief=True, sens=None):
    #     &#34;&#34;&#34;Print a report for failure modes and effects.

    #     The report is sorted by fatality rate descending.&#34;&#34;&#34;
    #     self.fail_modes.sort(key=lambda x: x.phi, reverse=True)
    #     sens = sens or 0/ureg.hr
    #     title = f&#39;ODH report for {self}&#39;
    #     padding = len(title) + 10
    #     print(&#39;#&#39;*padding)
    #     print(title)
    #     print(&#39;-&#39;*padding)
    #     if brief:
    #         print(&#39;Printing brief ODH report&#39;)
    #         print(f&#39;Only leaks with Fatality rate &gt; {sens} are shown&#39;)
    #     for f_mode in self.fail_modes:
    #         if f_mode.phi &gt;= sens or not brief:
    #             print()
    #             print(f&#39; Source:               {f_mode.source.name}&#39;)
    #             print(f&#39; Failure:              {f_mode.name}&#39;)
    #             print(f&#39; Fatality rate:        {f_mode.phi.to(1/ureg.hr):.2~}&#39;)
    #             print(f&#39; Building is powered:  {not f_mode.outage}&#39;)
    #             print(f&#39; Oxygen concentration: {f_mode.O2_conc:.0%}, &#39;
    #                   f&#39;{f_mode.O2_conc/0.21:.0%} percent of norm&#39;)
    #             print(f&#39; Leak failure rate:    {f_mode.leak_fr:.3g~}&#39;)
    #             print(&#39; ODH protection PFD:    &#39;
    #                   f&#39;{(f_mode.P_i/f_mode.leak_fr).to(ureg.dimensionless):.2~}&#39;)
    #             print(f&#39; Total failure rate:   {f_mode.P_i.to(1/ureg.hr):.2~}&#39;)
    #             print(f&#39; Leak rate:            {f_mode.q_leak:.2~}&#39;)
    #             print(f&#39; Event duration:       {f_mode.tau:.2~}&#39;)
    #             print(f&#39; Fans working:         {f_mode.N_fan}&#39;)
    #             print(f&#39; Fan rate:             {f_mode.Q_fan:.2~}&#39;)
    #             print(f&#39; Fatality prob:        {f_mode.F_i:.0%}&#39;)

    def make_doc_table(self, sens=None):
        &#34;&#34;&#34;Make a short table for failure modes and effects to be included to a document.

        The report is sorted by fatality rate descending.&#34;&#34;&#34;
        self.fail_modes.sort(key=lambda x: x.phi, reverse=True)
        sens = sens or 0/ureg.hr
        table = [
            [&#34;Failure mode&#34;, &#34;Fans on&#34;, &#34;O_2&#34;, &#34;Duration, min&#34;, &#34;\\phi_i&#34;],
            None]
        for f_mode in self.fail_modes:
            if f_mode.phi &lt;= sens:
                break
            row = []
            row.append(f&#39;{f_mode.source.name} {f_mode.name}&#39;)
            row.append(f&#39;{f_mode.N_fan}&#39;)
            row.append(f&#39;{f_mode.O2_conc:.0%}&#39;)
            row.append(f&#39;{f_mode.tau.m_as(ureg.min):,.1f}&#39;)
            row.append(f&#39;{f_mode.phi.m_as(1/ureg.hr):.2e}&#39;)
            table.append(row)
        return table

    def make_excel_table(self, filename=&#39;ODH_report&#39;):
        &#34;&#34;&#34;Make a table with the calculation results.&#34;&#34;&#34;
        table = []
        header = [&#39;Source&#39;, &#39;Failure&#39;, &#39;Fluid&#39;, &#39;Event failure rate, 1/hr&#39;,
                  &#39;# of&#39;, &#39;Total failure rate, 1/hr&#39;, &#39;Leak rate, SCFM&#39;,
                  &#39;# fans working&#39;, &#39;Fan rate, SCFM&#39;, &#39;Event duration, min&#39;,
                  &#39;Oxygen concentration&#39;, &#39;Fatality prob&#39;, &#39;Scenario&#39;, &#39;Scenario prob&#39;,
                  &#39;Fatality rate, 1/hr&#39;]
        # &#39;Total failure rate&#39;, &#39;ODH protection PFD&#39;, &#39;Building is powered&#39;
        table.append(header)
        self.fail_modes.sort(key=lambda x: x.phi, reverse=True)
        for f_mode in self.fail_modes:
            tau = f_mode.tau.m_as(ureg.min)
            if tau == float(&#39;inf&#39;):
                # Handling infinite release
                tau = str(tau)
            if f_mode.is_const:
                event_fr = f_mode.leak_fr
            else:
                event_fr = f_mode.leak_fr/f_mode.N
            table.append([
                f_mode.source.name,
                f_mode.name,
                str(f_mode.fluid),
                event_fr.m_as(1/ureg.hr),
                f_mode.N,
                f_mode.leak_fr.m_as(1/ureg.hr),
                f_mode.q_leak.m_as(ureg.ft**3/ureg.min),
                f_mode.N_fan,
                f_mode.Q_fan.m_as(ureg.ft**3/ureg.min),
                tau,
                f_mode.O2_conc,
                f_mode.F_i,
                f_mode.scenario,
                f_mode.P_i/f_mode.leak_fr,
                f_mode.phi.m_as(1/ureg.hr)])
        wb_options = {}
        filename += &#39;.xlsx&#39;
        with xlsxwriter.Workbook(filename, wb_options) as workbook:
            worksheet = workbook.add_worksheet()
            for row_n, row in enumerate(table):
                for col_n, data in enumerate(row):
                    worksheet.write(row_n, col_n, data)
            header_format = workbook.add_format({&#39;bold&#39;: True,
                                                 &#39;font_size&#39;: 12,
                                                 &#39;bottom&#39;: 3})
            sci_format = workbook.add_format({&#39;num_format&#39;: &#39;0.00E+00&#39;},)
            # flow_format = workbook.add_format({&#39;num_format&#39;: &#39;#&#39;},)
            percent_format = workbook.add_format({&#39;num_format&#39;: &#39;0%&#39;},)
            number_format = workbook.add_format({&#39;num_format&#39;: &#39;0&#39;},)
            worksheet.set_row(0, None, header_format)
            worksheet.set_column(3, 3, None, sci_format)
            worksheet.set_column(5, 5, None, sci_format)
            # worksheet.set_column(5, 5, None, flow_format)
            worksheet.set_column(6, 6, None, sci_format)
            worksheet.set_column(9, 9, None, sci_format)
            worksheet.set_column(10, 10, None, percent_format)
            worksheet.set_column(11, 11, None, sci_format)
            worksheet.set_column(13, 14, None, sci_format)
            # Writing total/summary
            N_rows = len(table)
            N_cols = len(table[0])
            worksheet.write(N_rows+1, N_cols-2, &#39;Total fatality rate, 1/hr&#39;)
            worksheet.write(N_rows+1, N_cols-1,
                            self.phi.m_as(1/ureg.hr))
            worksheet.write(N_rows+2, N_cols-2, &#39;ODH class&#39;)
            worksheet.write(N_rows+2, N_cols-1, self.odh_class,
                            number_format)
            worksheet.autofit()
            worksheet.conditional_format(
                1, N_cols-1, N_rows-1, N_cols-1,
                {&#39;type&#39;: &#39;3_color_scale&#39;, &#39;min_color&#39;: &#39;#008000&#39;,
                 &#39;max_color&#39;: &#39;#FF0000&#39;})
            worksheet.freeze_panes(1, 0)

    def __str__(self):
        return (f&#39;Volume: {self.name}, {self.volume.to(ureg.ft**3):~}&#39;)</code></pre>
</details>
<div class="desc"><p>A class to represent a building or a part of a building that is affected by
inert gas leaks.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>name</code></strong> :&ensp;<code>str</code></dt>
<dd>The name of the volume.</dd>
<dt><strong><code>volume</code></strong> :&ensp;<code>ureg.Quantity, [length]^3</code></dt>
<dd>The volume of the building or part of the building.</dd>
</dl>
<h2 id="attributes">Attributes</h2>
<dl>
<dt><strong><code>name</code></strong> :&ensp;<code>str</code></dt>
<dd>The name of the volume.</dd>
<dt><strong><code>volume</code></strong> :&ensp;<code>ureg.Quantity, [length]^3</code></dt>
<dd>The volume of the building or part of the building.</dd>
<dt><strong><code>vent</code></strong> :&ensp;<code><a title="CryoToolBox.odh.BuildVent" href="#CryoToolBox.odh.BuildVent">BuildVent</a></code></dt>
<dd>The ventilation system of the building or part of the building.</dd>
<dt><strong><code>power</code></strong> :&ensp;<code><a title="CryoToolBox.odh.BuildPower" href="#CryoToolBox.odh.BuildPower">BuildPower</a></code></dt>
<dd>The power system of the building or part of the building.</dd>
</dl>
<h2 id="methods">Methods</h2>
<p>info()
Display information on the volume.
odh(sources, power_outage=False)
Calculate ODH fatality rate for given <code><a title="CryoToolBox.odh.Source" href="#CryoToolBox.odh.Source">Source</a></code>s.
_fatality_no_power(source, leak, power_outage)
Calculate fatality rate in the event of power failure.
_fatality_no_odh(source, leak)
Calculate fatality rate in the event of ODH system failure.
_fatality_with_fans(source, leak)
Calculate fatality rate for any number of fans operational.
_add_failure_mode(P_event, tau_event, failure_rate, source, leak, Q_fan,
N_fans, power_outage)
Add a failure mode.
_fatality_const_leak(source, leak, power_outage)
Calculate fatality rates for constant leak case.
_fatality_prob(O2_conc)
Calculate fatality probability for given oxygen concentration.</p>
<p>Define a volume affected by inert gas release from
a <code><a title="CryoToolBox.odh.Source" href="#CryoToolBox.odh.Source">Source</a></code>.</p>
<h2 id="parameters_1">Parameters</h2>
<dl>
<dt><strong><code>name</code></strong> :&ensp;<code>str</code></dt>
<dd>Name of the volume.</dd>
<dt><strong><code>volume</code></strong> :&ensp;<code>ureg.Quantity, [length]^3</code></dt>
<dd>Volume of the building or part of the building.</dd>
</dl></div>
<h3>Instance variables</h3>
<dl>
<dt id="CryoToolBox.odh.Volume.odh_class"><code class="name">prop <span class="ident">odh_class</span></code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def odh_class(self):
    &#34;&#34;&#34;Calculate ODH class as defined in FESHM 4240.

    Returns
    -------
    int
        ODH class.
    &#34;&#34;&#34;
    if self.phi &lt; 1e-7/ureg.hr:
        return 0
    elif self.phi &lt; 1e-5/ureg.hr:
        return 1
    elif self.phi &lt; 1e-3/ureg.hr:
        return 2
    else:
        # TODO add a custom exception for ODH &gt; 2
        raise ODHError(&#39;ODH fatality rate is too high. Please, check calculations.&#39;)</code></pre>
</details>
<div class="desc"><p>Calculate ODH class as defined in FESHM 4240.</p>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>int</code></dt>
<dd>ODH class.</dd>
</dl></div>
</dd>
<dt id="CryoToolBox.odh.Volume.phi"><code class="name">prop <span class="ident">phi</span></code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def phi(self):
    return sum((fm.phi for fm in self.fail_modes)).to(1/ureg.hr)</code></pre>
</details>
<div class="desc"></div>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="CryoToolBox.odh.Volume.info"><code class="name flex">
<span>def <span class="ident">info</span></span>(<span>self)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def info(self):
    &#34;&#34;&#34;
    Display information on the volume.
    &#34;&#34;&#34;
    print(f&#39;{self.name} with affected volume of {self.volume:,.0f~}.&#39;)
    print(self.power.info())
    print(self.vent.info())</code></pre>
</details>
<div class="desc"><p>Display information on the volume.</p></div>
</dd>
<dt id="CryoToolBox.odh.Volume.make_doc_table"><code class="name flex">
<span>def <span class="ident">make_doc_table</span></span>(<span>self, sens=None)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def make_doc_table(self, sens=None):
    &#34;&#34;&#34;Make a short table for failure modes and effects to be included to a document.

    The report is sorted by fatality rate descending.&#34;&#34;&#34;
    self.fail_modes.sort(key=lambda x: x.phi, reverse=True)
    sens = sens or 0/ureg.hr
    table = [
        [&#34;Failure mode&#34;, &#34;Fans on&#34;, &#34;O_2&#34;, &#34;Duration, min&#34;, &#34;\\phi_i&#34;],
        None]
    for f_mode in self.fail_modes:
        if f_mode.phi &lt;= sens:
            break
        row = []
        row.append(f&#39;{f_mode.source.name} {f_mode.name}&#39;)
        row.append(f&#39;{f_mode.N_fan}&#39;)
        row.append(f&#39;{f_mode.O2_conc:.0%}&#39;)
        row.append(f&#39;{f_mode.tau.m_as(ureg.min):,.1f}&#39;)
        row.append(f&#39;{f_mode.phi.m_as(1/ureg.hr):.2e}&#39;)
        table.append(row)
    return table</code></pre>
</details>
<div class="desc"><p>Make a short table for failure modes and effects to be included to a document.</p>
<p>The report is sorted by fatality rate descending.</p></div>
</dd>
<dt id="CryoToolBox.odh.Volume.make_excel_table"><code class="name flex">
<span>def <span class="ident">make_excel_table</span></span>(<span>self, filename='ODH_report')</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def make_excel_table(self, filename=&#39;ODH_report&#39;):
    &#34;&#34;&#34;Make a table with the calculation results.&#34;&#34;&#34;
    table = []
    header = [&#39;Source&#39;, &#39;Failure&#39;, &#39;Fluid&#39;, &#39;Event failure rate, 1/hr&#39;,
              &#39;# of&#39;, &#39;Total failure rate, 1/hr&#39;, &#39;Leak rate, SCFM&#39;,
              &#39;# fans working&#39;, &#39;Fan rate, SCFM&#39;, &#39;Event duration, min&#39;,
              &#39;Oxygen concentration&#39;, &#39;Fatality prob&#39;, &#39;Scenario&#39;, &#39;Scenario prob&#39;,
              &#39;Fatality rate, 1/hr&#39;]
    # &#39;Total failure rate&#39;, &#39;ODH protection PFD&#39;, &#39;Building is powered&#39;
    table.append(header)
    self.fail_modes.sort(key=lambda x: x.phi, reverse=True)
    for f_mode in self.fail_modes:
        tau = f_mode.tau.m_as(ureg.min)
        if tau == float(&#39;inf&#39;):
            # Handling infinite release
            tau = str(tau)
        if f_mode.is_const:
            event_fr = f_mode.leak_fr
        else:
            event_fr = f_mode.leak_fr/f_mode.N
        table.append([
            f_mode.source.name,
            f_mode.name,
            str(f_mode.fluid),
            event_fr.m_as(1/ureg.hr),
            f_mode.N,
            f_mode.leak_fr.m_as(1/ureg.hr),
            f_mode.q_leak.m_as(ureg.ft**3/ureg.min),
            f_mode.N_fan,
            f_mode.Q_fan.m_as(ureg.ft**3/ureg.min),
            tau,
            f_mode.O2_conc,
            f_mode.F_i,
            f_mode.scenario,
            f_mode.P_i/f_mode.leak_fr,
            f_mode.phi.m_as(1/ureg.hr)])
    wb_options = {}
    filename += &#39;.xlsx&#39;
    with xlsxwriter.Workbook(filename, wb_options) as workbook:
        worksheet = workbook.add_worksheet()
        for row_n, row in enumerate(table):
            for col_n, data in enumerate(row):
                worksheet.write(row_n, col_n, data)
        header_format = workbook.add_format({&#39;bold&#39;: True,
                                             &#39;font_size&#39;: 12,
                                             &#39;bottom&#39;: 3})
        sci_format = workbook.add_format({&#39;num_format&#39;: &#39;0.00E+00&#39;},)
        # flow_format = workbook.add_format({&#39;num_format&#39;: &#39;#&#39;},)
        percent_format = workbook.add_format({&#39;num_format&#39;: &#39;0%&#39;},)
        number_format = workbook.add_format({&#39;num_format&#39;: &#39;0&#39;},)
        worksheet.set_row(0, None, header_format)
        worksheet.set_column(3, 3, None, sci_format)
        worksheet.set_column(5, 5, None, sci_format)
        # worksheet.set_column(5, 5, None, flow_format)
        worksheet.set_column(6, 6, None, sci_format)
        worksheet.set_column(9, 9, None, sci_format)
        worksheet.set_column(10, 10, None, percent_format)
        worksheet.set_column(11, 11, None, sci_format)
        worksheet.set_column(13, 14, None, sci_format)
        # Writing total/summary
        N_rows = len(table)
        N_cols = len(table[0])
        worksheet.write(N_rows+1, N_cols-2, &#39;Total fatality rate, 1/hr&#39;)
        worksheet.write(N_rows+1, N_cols-1,
                        self.phi.m_as(1/ureg.hr))
        worksheet.write(N_rows+2, N_cols-2, &#39;ODH class&#39;)
        worksheet.write(N_rows+2, N_cols-1, self.odh_class,
                        number_format)
        worksheet.autofit()
        worksheet.conditional_format(
            1, N_cols-1, N_rows-1, N_cols-1,
            {&#39;type&#39;: &#39;3_color_scale&#39;, &#39;min_color&#39;: &#39;#008000&#39;,
             &#39;max_color&#39;: &#39;#FF0000&#39;})
        worksheet.freeze_panes(1, 0)</code></pre>
</details>
<div class="desc"><p>Make a table with the calculation results.</p></div>
</dd>
<dt id="CryoToolBox.odh.Volume.odh"><code class="name flex">
<span>def <span class="ident">odh</span></span>(<span>self, sources, power_outage=False)</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def odh(self, sources, power_outage=False):
    &#34;&#34;&#34;Calculate ODH fatality rate for given `Source`s.

    For each leak of each source ODH conditions are analyzed and
    fatality rates are calculated. The results are collected in
    fail_modes list.

    Parameters
    ----------
    sources : List[Source]
        Sources affecting the volume.
    power_outage : bool
        Shows whether there is a power outage is in effect.
        Default is no outage.

    Returns
    -------
    None
    &#34;&#34;&#34;
    self.fail_modes = []
    for source in sources:
        for leak in source.leaks:
            if not leak._is_const:
                self._fatality_no_power(source, leak, power_outage)
                if not power_outage:
                    self._fatality_no_odh(source, leak)
                    self._fatality_with_fans(source, leak)
            else:
                self._fatality_const_leak(source, leak, power_outage)</code></pre>
</details>
<div class="desc"><p>Calculate ODH fatality rate for given <code><a title="CryoToolBox.odh.Source" href="#CryoToolBox.odh.Source">Source</a></code>s.</p>
<p>For each leak of each source ODH conditions are analyzed and
fatality rates are calculated. The results are collected in
fail_modes list.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>sources</code></strong> :&ensp;<code>List[<a title="CryoToolBox.odh.Source" href="#CryoToolBox.odh.Source">Source</a>]</code></dt>
<dd>Sources affecting the volume.</dd>
<dt><strong><code>power_outage</code></strong> :&ensp;<code>bool</code></dt>
<dd>Shows whether there is a power outage is in effect.
Default is no outage.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>None</code></dt>
<dd>&nbsp;</dd>
</dl></div>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="CryoToolBox" href="index.html">CryoToolBox</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="two-column">
<li><code><a title="CryoToolBox.odh.O2_sudden_release" href="#CryoToolBox.odh.O2_sudden_release">O2_sudden_release</a></code></li>
<li><code><a title="CryoToolBox.odh.PFD_avg" href="#CryoToolBox.odh.PFD_avg">PFD_avg</a></code></li>
<li><code><a title="CryoToolBox.odh.conc_after" href="#CryoToolBox.odh.conc_after">conc_after</a></code></li>
<li><code><a title="CryoToolBox.odh.conc_final" href="#CryoToolBox.odh.conc_final">conc_final</a></code></li>
<li><code><a title="CryoToolBox.odh.conc_vent" href="#CryoToolBox.odh.conc_vent">conc_vent</a></code></li>
<li><code><a title="CryoToolBox.odh.hole_leak" href="#CryoToolBox.odh.hole_leak">hole_leak</a></code></li>
<li><code><a title="CryoToolBox.odh.prob_m_of_n" href="#CryoToolBox.odh.prob_m_of_n">prob_m_of_n</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="CryoToolBox.odh.BuildPower" href="#CryoToolBox.odh.BuildPower">BuildPower</a></code></h4>
<ul class="two-column">
<li><code><a title="CryoToolBox.odh.BuildPower.backup_pfd" href="#CryoToolBox.odh.BuildPower.backup_pfd">backup_pfd</a></code></li>
<li><code><a title="CryoToolBox.odh.BuildPower.info" href="#CryoToolBox.odh.BuildPower.info">info</a></code></li>
<li><code><a title="CryoToolBox.odh.BuildPower.lambda_power" href="#CryoToolBox.odh.BuildPower.lambda_power">lambda_power</a></code></li>
<li><code><a title="CryoToolBox.odh.BuildPower.max_outage" href="#CryoToolBox.odh.BuildPower.max_outage">max_outage</a></code></li>
<li><code><a title="CryoToolBox.odh.BuildPower.pfd" href="#CryoToolBox.odh.BuildPower.pfd">pfd</a></code></li>
<li><code><a title="CryoToolBox.odh.BuildPower.power_pfd" href="#CryoToolBox.odh.BuildPower.power_pfd">power_pfd</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="CryoToolBox.odh.BuildVent" href="#CryoToolBox.odh.BuildVent">BuildVent</a></code></h4>
<ul class="two-column">
<li><code><a title="CryoToolBox.odh.BuildVent.N_fans" href="#CryoToolBox.odh.BuildVent.N_fans">N_fans</a></code></li>
<li><code><a title="CryoToolBox.odh.BuildVent.PFD_ODH" href="#CryoToolBox.odh.BuildVent.PFD_ODH">PFD_ODH</a></code></li>
<li><code><a title="CryoToolBox.odh.BuildVent.Q_fan" href="#CryoToolBox.odh.BuildVent.Q_fan">Q_fan</a></code></li>
<li><code><a title="CryoToolBox.odh.BuildVent.Test_period" href="#CryoToolBox.odh.BuildVent.Test_period">Test_period</a></code></li>
<li><code><a title="CryoToolBox.odh.BuildVent.const_vent" href="#CryoToolBox.odh.BuildVent.const_vent">const_vent</a></code></li>
<li><code><a title="CryoToolBox.odh.BuildVent.fan_flowrates" href="#CryoToolBox.odh.BuildVent.fan_flowrates">fan_flowrates</a></code></li>
<li><code><a title="CryoToolBox.odh.BuildVent.info" href="#CryoToolBox.odh.BuildVent.info">info</a></code></li>
<li><code><a title="CryoToolBox.odh.BuildVent.lambda_fan" href="#CryoToolBox.odh.BuildVent.lambda_fan">lambda_fan</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="CryoToolBox.odh.ConstLeak" href="#CryoToolBox.odh.ConstLeak">ConstLeak</a></code></h4>
<ul class="">
<li><code><a title="CryoToolBox.odh.ConstLeak.fluid" href="#CryoToolBox.odh.ConstLeak.fluid">fluid</a></code></li>
<li><code><a title="CryoToolBox.odh.ConstLeak.name" href="#CryoToolBox.odh.ConstLeak.name">name</a></code></li>
<li><code><a title="CryoToolBox.odh.ConstLeak.q_std" href="#CryoToolBox.odh.ConstLeak.q_std">q_std</a></code></li>
<li><code><a title="CryoToolBox.odh.ConstLeak.tau" href="#CryoToolBox.odh.ConstLeak.tau">tau</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="CryoToolBox.odh.ConstLeakNoVent" href="#CryoToolBox.odh.ConstLeakNoVent">ConstLeakNoVent</a></code></h4>
</li>
<li>
<h4><code><a title="CryoToolBox.odh.ConstLeakTooBig" href="#CryoToolBox.odh.ConstLeakTooBig">ConstLeakTooBig</a></code></h4>
</li>
<li>
<h4><code><a title="CryoToolBox.odh.FailureMode" href="#CryoToolBox.odh.FailureMode">FailureMode</a></code></h4>
<ul class="two-column">
<li><code><a title="CryoToolBox.odh.FailureMode.F_i" href="#CryoToolBox.odh.FailureMode.F_i">F_i</a></code></li>
<li><code><a title="CryoToolBox.odh.FailureMode.N" href="#CryoToolBox.odh.FailureMode.N">N</a></code></li>
<li><code><a title="CryoToolBox.odh.FailureMode.N_fan" href="#CryoToolBox.odh.FailureMode.N_fan">N_fan</a></code></li>
<li><code><a title="CryoToolBox.odh.FailureMode.O2_conc" href="#CryoToolBox.odh.FailureMode.O2_conc">O2_conc</a></code></li>
<li><code><a title="CryoToolBox.odh.FailureMode.P_i" href="#CryoToolBox.odh.FailureMode.P_i">P_i</a></code></li>
<li><code><a title="CryoToolBox.odh.FailureMode.Q_fan" href="#CryoToolBox.odh.FailureMode.Q_fan">Q_fan</a></code></li>
<li><code><a title="CryoToolBox.odh.FailureMode.fluid" href="#CryoToolBox.odh.FailureMode.fluid">fluid</a></code></li>
<li><code><a title="CryoToolBox.odh.FailureMode.is_const" href="#CryoToolBox.odh.FailureMode.is_const">is_const</a></code></li>
<li><code><a title="CryoToolBox.odh.FailureMode.leak_fr" href="#CryoToolBox.odh.FailureMode.leak_fr">leak_fr</a></code></li>
<li><code><a title="CryoToolBox.odh.FailureMode.name" href="#CryoToolBox.odh.FailureMode.name">name</a></code></li>
<li><code><a title="CryoToolBox.odh.FailureMode.outage" href="#CryoToolBox.odh.FailureMode.outage">outage</a></code></li>
<li><code><a title="CryoToolBox.odh.FailureMode.phi" href="#CryoToolBox.odh.FailureMode.phi">phi</a></code></li>
<li><code><a title="CryoToolBox.odh.FailureMode.q_leak" href="#CryoToolBox.odh.FailureMode.q_leak">q_leak</a></code></li>
<li><code><a title="CryoToolBox.odh.FailureMode.scenario" href="#CryoToolBox.odh.FailureMode.scenario">scenario</a></code></li>
<li><code><a title="CryoToolBox.odh.FailureMode.source" href="#CryoToolBox.odh.FailureMode.source">source</a></code></li>
<li><code><a title="CryoToolBox.odh.FailureMode.tau" href="#CryoToolBox.odh.FailureMode.tau">tau</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="CryoToolBox.odh.Leak" href="#CryoToolBox.odh.Leak">Leak</a></code></h4>
<ul class="two-column">
<li><code><a title="CryoToolBox.odh.Leak.N_events" href="#CryoToolBox.odh.Leak.N_events">N_events</a></code></li>
<li><code><a title="CryoToolBox.odh.Leak.failure_rate" href="#CryoToolBox.odh.Leak.failure_rate">failure_rate</a></code></li>
<li><code><a title="CryoToolBox.odh.Leak.fluid" href="#CryoToolBox.odh.Leak.fluid">fluid</a></code></li>
<li><code><a title="CryoToolBox.odh.Leak.name" href="#CryoToolBox.odh.Leak.name">name</a></code></li>
<li><code><a title="CryoToolBox.odh.Leak.q_std" href="#CryoToolBox.odh.Leak.q_std">q_std</a></code></li>
<li><code><a title="CryoToolBox.odh.Leak.tau" href="#CryoToolBox.odh.Leak.tau">tau</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="CryoToolBox.odh.ODHError" href="#CryoToolBox.odh.ODHError">ODHError</a></code></h4>
</li>
<li>
<h4><code><a title="CryoToolBox.odh.Source" href="#CryoToolBox.odh.Source">Source</a></code></h4>
<ul class="">
<li><code><a title="CryoToolBox.odh.Source.add_const_leak" href="#CryoToolBox.odh.Source.add_const_leak">add_const_leak</a></code></li>
<li><code><a title="CryoToolBox.odh.Source.add_dewar_insulation_failure" href="#CryoToolBox.odh.Source.add_dewar_insulation_failure">add_dewar_insulation_failure</a></code></li>
<li><code><a title="CryoToolBox.odh.Source.add_failure_mode" href="#CryoToolBox.odh.Source.add_failure_mode">add_failure_mode</a></code></li>
<li><code><a title="CryoToolBox.odh.Source.add_flange_failure" href="#CryoToolBox.odh.Source.add_flange_failure">add_flange_failure</a></code></li>
<li><code><a title="CryoToolBox.odh.Source.add_line_failure" href="#CryoToolBox.odh.Source.add_line_failure">add_line_failure</a></code></li>
<li><code><a title="CryoToolBox.odh.Source.add_pipe_failure" href="#CryoToolBox.odh.Source.add_pipe_failure">add_pipe_failure</a></code></li>
<li><code><a title="CryoToolBox.odh.Source.add_pressure_vessel_failure" href="#CryoToolBox.odh.Source.add_pressure_vessel_failure">add_pressure_vessel_failure</a></code></li>
<li><code><a title="CryoToolBox.odh.Source.add_valve_failure" href="#CryoToolBox.odh.Source.add_valve_failure">add_valve_failure</a></code></li>
<li><code><a title="CryoToolBox.odh.Source.combine" href="#CryoToolBox.odh.Source.combine">combine</a></code></li>
<li><code><a title="CryoToolBox.odh.Source.print_leaks" href="#CryoToolBox.odh.Source.print_leaks">print_leaks</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="CryoToolBox.odh.Volume" href="#CryoToolBox.odh.Volume">Volume</a></code></h4>
<ul class="two-column">
<li><code><a title="CryoToolBox.odh.Volume.info" href="#CryoToolBox.odh.Volume.info">info</a></code></li>
<li><code><a title="CryoToolBox.odh.Volume.make_doc_table" href="#CryoToolBox.odh.Volume.make_doc_table">make_doc_table</a></code></li>
<li><code><a title="CryoToolBox.odh.Volume.make_excel_table" href="#CryoToolBox.odh.Volume.make_excel_table">make_excel_table</a></code></li>
<li><code><a title="CryoToolBox.odh.Volume.odh" href="#CryoToolBox.odh.Volume.odh">odh</a></code></li>
<li><code><a title="CryoToolBox.odh.Volume.odh_class" href="#CryoToolBox.odh.Volume.odh_class">odh_class</a></code></li>
<li><code><a title="CryoToolBox.odh.Volume.phi" href="#CryoToolBox.odh.Volume.phi">phi</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.11.6</a>.</p>
</footer>
</body>
</html>
