<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>CryoToolBox.cp_wrapper API documentation</title>
<meta name="description" content="Wrapper module for CoolProp&#39;s AbstractState â€¦" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>CryoToolBox.cp_wrapper</code></h1>
</header>
<section id="section-intro">
<p>Wrapper module for CoolProp's AbstractState.</p>
<ol>
<li>Provides unit support</li>
<li>Adds some small useful functions</li>
</ol>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;Wrapper module for CoolProp&#39;s AbstractState.

1. Provides unit support
2. Adds some small useful functions

&#34;&#34;&#34;
import CoolProp.CoolProp as CP
from math import inf
from .std_conditions import ureg, T_NTP, P_NTP, P_MSC, T_MSC, P_STD, T_STD

CP_const_unit = {
    &#39;gas_constant&#39;: (CP.igas_constant, ureg.J/ureg.mol/ureg.K),
    &#39;molar_mass&#39;: (CP.imolar_mass, ureg.kg/ureg.mol),
    # &#39;acentric_factor&#39;: (CP.iacentric_factor, ),
    # &#39;Dmolar_reducing&#39;: (CP.irhomolar_reducing, ),
    &#39;Dmolar_critical&#39;: (CP.irhomolar_critical, ureg.mol/ureg.m**3),
    &#39;T_reducing&#39;: (CP.iT_reducing, ureg.K),
    &#39;T_critical&#39;: (CP.iT_critical, ureg.K),
    # &#39;Dmass_reducing&#39;: (CP.irhomass_reducing, ),
    &#39;Dmass_critical&#39;: (CP.irhomass_critical, ureg.kg/ureg.m**3),
    &#39;P_critical&#39;: (CP.iP_critical, ureg.Pa),
    &#39;P_reducing&#39;: (CP.iP_reducing, ureg.Pa),
    &#39;T_triple&#39;: (CP.iT_triple, ureg.K),
    &#39;P_triple&#39;: (CP.iP_triple, ureg.Pa),
    &#39;T_min&#39;: (CP.iT_min, ureg.K),
    &#39;T_max&#39;: (CP.iT_max, ureg.K),
    &#39;P_max&#39;: (CP.iP_max, ureg.Pa),
    &#39;P_min&#39;: (CP.iP_min, ureg.Pa),
    # &#39;dipole_moment&#39;: (CP.idipole_moment, ),
    &#39;T&#39;: (CP.iT, ureg.K),
    &#39;P&#39;: (CP.iP, ureg.Pa),
    &#39;Q&#39;: (CP.iQ, ureg.mol/ureg.mol),
    # &#39;Tau&#39;: (CP.iTau, ),
    # &#39;Delta&#39;: (CP.iDelta, ),
    &#39;Dmolar&#39;: (CP.iDmolar, ureg.mol/ureg.m**3),
    &#39;Hmolar&#39;: (CP.iHmolar, ureg.J/ureg.mol),
    &#39;Smolar&#39;: (CP.iSmolar, ureg.J/ureg.mol/ureg.K),
    &#39;Cpmolar&#39;: (CP.iCpmolar, ureg.J/ureg.mol/ureg.K),
    # &#39;Cp0molar&#39;: (CP.iCp0molar, ureg.J/ureg.mol/ureg.K),
    &#39;Cvmolar&#39;: (CP.iCvmolar, ureg.J/ureg.mol/ureg.K),
    &#39;Umolar&#39;: (CP.iUmolar, ureg.J/ureg.mol),
    # &#39;Gmolar&#39;: (CP.iGmolar, ),
    # &#39;Helmholtzmolar&#39;: (CP.iHelmholtzmolar, ),
    # &#39;Smolar_residual&#39;: (CP.iSmolar_residual, ),
    &#39;Dmass&#39;: (CP.iDmass, ureg.kg/ureg.m**3),
    &#39;Hmass&#39;: (CP.iHmass, ureg.J/ureg.kg),
    &#39;Smass&#39;: (CP.iSmass, ureg.J/ureg.kg/ureg.K),
    &#39;Cpmass&#39;: (CP.iCpmass, ureg.J/ureg.kg/ureg.K),
    # &#39;Cp0mass&#39;: (CP.iCp0mass, ureg.J/ureg.kg/ureg.K),
    &#39;Cvmass&#39;: (CP.iCvmass, ureg.J/ureg.kg/ureg.K),
    &#39;Umass&#39;: (CP.iUmass, ureg.J/ureg.kg),
    # &#39;Gmass&#39;: (CP.iGmass, ),
    # &#39;Helmholtzmass&#39;: (CP.iHelmholtzmass, ),
    &#39;viscosity&#39;: (CP.iviscosity, ureg.Pa*ureg.s),
    &#39;conductivity&#39;: (CP.iconductivity, ureg.W/ureg.m/ureg.K),
    &#39;surface_tension&#39;: (CP.isurface_tension, ureg.N/ureg.m),
    &#39;Prandtl&#39;: (CP.iPrandtl, None),
    &#39;speed_sound&#39;: (CP.ispeed_sound, ureg.m/ureg.s),
    &#39;isothermal_compressibility&#39;: (CP.iisothermal_compressibility,
                                   ureg.Pa**-1),
    &#39;isobaric_expansion_coefficient&#39;:
    (CP.iisobaric_expansion_coefficient, ureg.K**-1),
    &#39;isentropic_expansion_coefficient&#39;:
    (CP.iisentropic_expansion_coefficient, ureg.dimensionless),
    # &#39;fundamental_derivative_of_gas_dynamics&#39;:
    # (CP.ifundamental_derivative_of_gas_dynamics, ),
    # &#39;alphar&#39;: (CP.ialphar, ),
    # &#39;alpha0&#39;: (CP.ialpha0, ),
    # &#39;Bvirial&#39;: (CP.iBvirial, ),
    # &#39;Cvirial&#39;: (CP.iCvirial, ),
    # &#39;dBvirial_dT&#39;: (CP.idBvirial_dT, ),
    # &#39;dCvirial_dT&#39;: (CP.idCvirial_dT, ),
    &#39;Z&#39;: (CP.iZ, ureg.dimensionless),
    # &#39;PIP&#39;: (CP.iPIP, ),
    # &#39;fraction_min&#39;: (CP.ifraction_min, ),
    # &#39;fraction_max&#39;: (CP.ifraction_max, ),
    # &#39;T_freeze&#39;: (CP.iT_freeze, ),
    # &#39;GWP20&#39;: (CP.iGWP20, ),
    # &#39;GWP100&#39;: (CP.iGWP100, ),
    # &#39;GWP500&#39;: (CP.iGWP500, ),
    # &#39;FH&#39;: (CP.iFH, ),
    # &#39;HH&#39;: (CP.iHH, ),
    # &#39;PH&#39;: (CP.iPH, ),
    # &#39;ODP&#39;: (CP.iODP, ),
    &#39;Phase&#39;: (CP.iPhase, ureg.dimensionless),
    &#39;C_us&#39;: (None,  # unit defined for external use
             ureg.lb/(ureg.hr*ureg.lbf)*(ureg.degR)**0.5),
    &#39;C_m&#39;: (None,  # unit defined for external use
            ureg.s**2/(ureg.hr*ureg.m)*(ureg.K)**0.5)
}

CP_inputs = {
    &#39;QT&#39;: CP.QT_INPUTS,
    &#39;PQ&#39;: CP.PQ_INPUTS,
    &#39;QSmolar&#39;: CP.QSmolar_INPUTS,
    &#39;QSmass&#39;: CP.QSmass_INPUTS,
    &#39;HmolarQ&#39;: CP.HmolarQ_INPUTS,
    &#39;HmassQ&#39;: CP.HmassQ_INPUTS,
    &#39;DmolarQ&#39;: CP.DmolarQ_INPUTS,
    &#39;DmassQ&#39;: CP.DmassQ_INPUTS,
    &#39;PT&#39;: CP.PT_INPUTS,
    &#39;DmassT&#39;: CP.DmassT_INPUTS,
    &#39;DmolarT&#39;: CP.DmolarT_INPUTS,
    &#39;HmolarT&#39;: CP.HmolarT_INPUTS,
    &#39;HmassT&#39;: CP.HmassT_INPUTS,
    &#39;SmolarT&#39;: CP.SmolarT_INPUTS,
    &#39;SmassT&#39;: CP.SmassT_INPUTS,
    &#39;TUmolar&#39;: CP.TUmolar_INPUTS,
    &#39;TUmass&#39;: CP.TUmass_INPUTS,
    &#39;DmassP&#39;: CP.DmassP_INPUTS,
    &#39;DmolarP&#39;: CP.DmolarP_INPUTS,
    &#39;HmassP&#39;: CP.HmassP_INPUTS,
    &#39;HmolarP&#39;: CP.HmolarP_INPUTS,
    &#39;PSmass&#39;: CP.PSmass_INPUTS,
    &#39;PSmolar&#39;: CP.PSmolar_INPUTS,
    &#39;PUmass&#39;: CP.PUmass_INPUTS,
    &#39;PUmolar&#39;: CP.PUmolar_INPUTS,
    &#39;HmassSmass&#39;: CP.HmassSmass_INPUTS,
    &#39;HmolarSmolar&#39;: CP.HmolarSmolar_INPUTS,
    &#39;SmassUmass&#39;: CP.SmassUmass_INPUTS,
    &#39;SmolarUmolar&#39;: CP.SmolarUmolar_INPUTS,
    &#39;DmassHmass&#39;: CP.DmassHmass_INPUTS,
    &#39;DmolarHmolar&#39;: CP.DmolarHmolar_INPUTS,
    &#39;DmassSmass&#39;: CP.DmassSmass_INPUTS,
    &#39;DmolarSmolar&#39;: CP.DmolarSmolar_INPUTS,
    &#39;DmassUmass&#39;: CP.DmassUmass_INPUTS,
    &#39;DmolarUmolar&#39;: CP.DmolarUmolar_INPUTS,
}


class ThermState:
    def __init__(self, fluid, backend=&#34;HEOS&#34;, **state_parameters):
        &#34;&#34;&#34;
        Available backends: HEOS (opensource), REFPROP.
        See http://www.coolprop.org/coolprop/REFPROP.html for details.
        &#34;&#34;&#34;
        self._AbstractState = CP.AbstractState(backend, fluid)
        if state_parameters:
            self.update_kw(**state_parameters)

    def update_kw(self, **state_parameters):
        &#34;&#34;&#34;Update thermodynamic state using keyword arguments.&#34;&#34;&#34;
        if len(state_parameters) != 2:
            raise TypeError(f&#39;update_kw() takes 2 arguments \
            ({len(state_parameters)} given)&#39;)
        # TODO Code below can be simplified
        names = []
        values = []
        for name, value in state_parameters.items():
            names.append(name)
            values.append(value)
        self.update(names[0], values[0],
                    names[1], values[1])

    def update(self, name1, value1, name2, value2):
        if name1 &gt; name2:  # Sorting inputs alphabetically
            name1, name2 = name2, name1
            value1, value2 = value2, value1
        CP_input_str = name1 + name2
        CP_value1 = self.prepare_input(name1, value1)
        CP_value2 = self.prepare_input(name2, value2)
        self._AbstractState.update(
            CP_inputs[CP_input_str], CP_value1, CP_value2)

    @staticmethod
    def prepare_input(name, value):
        &#34;&#34;&#34;Prepare value to input to CoolProp.

        Converts the value to units expected by CoolProp
        (see `CP_const_unit`).

        Parameters
        ----------
        name : str
            Parameter name.
        value : ureg.Quantity
            Parameter value.

        Returns
        -------
        float
        &#34;&#34;&#34;
        if isinstance(value, (int, float)):
            return value  # Dimensionless
        else:
            unit = CP_const_unit[name][1]
            return value.to(unit).magnitude

    @property
    @ureg.wraps(CP_const_unit[&#39;T&#39;][1], None)
    def T_critical(self):
        return self._AbstractState.T_critical()

    @property
    @ureg.wraps(CP_const_unit[&#39;P&#39;][1], None)
    def P_critical(self):
        return self._AbstractState.p_critical()

    @property
    @ureg.wraps(CP_const_unit[&#39;Dmolar_critical&#39;][1], None)
    def Dmolar_critical(self):
        return self._AbstractState.rhomolar_critical()

    @property
    @ureg.wraps(CP_const_unit[&#39;Dmass_critical&#39;][1], None)
    def Dmass_critical(self):
        return self._AbstractState.rhomass_critical()

    @property
    @ureg.wraps(CP_const_unit[&#39;T&#39;][1], None)
    def T(self):
        return self._AbstractState.T()

    @property
    @ureg.wraps(CP_const_unit[&#39;Dmolar_critical&#39;][1], None)
    def Dmolar(self):
        return self._AbstractState.rhomolar()

    @property
    @ureg.wraps(CP_const_unit[&#39;Dmass_critical&#39;][1], None)
    def Dmass(self):
        return self._AbstractState.rhomass()

    @property
    @ureg.wraps(CP_const_unit[&#39;P&#39;][1], None)
    def P(self):
        return self._AbstractState.p()

    @property
    @ureg.wraps(CP_const_unit[&#39;Q&#39;][1], None)
    def Q(self):
        return self._AbstractState.Q()

    @property
    @ureg.wraps(CP_const_unit[&#39;molar_mass&#39;][1], None)
    def molar_mass(self):
        return self._AbstractState.molar_mass()

    @property
    @ureg.wraps(CP_const_unit[&#39;gas_constant&#39;][1], None)
    def gas_constant(self):
        return self._AbstractState.gas_constant()

    @property
    def specific_gas_constant(self):
        R_spec = self.gas_constant / self.molar_mass
        return R_spec

    @property
    # @ureg.wraps(CP_const_unit[&#39;Z&#39;][1], None)
    def compressibility_factor(self):
        Z_ = self.P * self.molar_mass / (self.Dmass*self.gas_constant*self.T)
        return Z_.m_as(ureg.dimensionless)
        # Temporarily unavailable function
        # return self._AbstractState.compressibility_factor()
    # Useful shorthand
    Z = compressibility_factor

    @property
    @ureg.wraps(CP_const_unit[&#39;Hmolar&#39;][1], None)
    def Hmolar(self):
        return self._AbstractState.hmolar()

    @property
    @ureg.wraps(CP_const_unit[&#39;Hmass&#39;][1], None)
    def Hmass(self):
        return self._AbstractState.hmass()

    @property
    @ureg.wraps(CP_const_unit[&#39;Smolar&#39;][1], None)
    def Smolar(self):
        return self._AbstractState.smolar()

    @property
    @ureg.wraps(CP_const_unit[&#39;Smass&#39;][1], None)
    def Smass(self):
        return self._AbstractState.smass()

    @property
    @ureg.wraps(CP_const_unit[&#39;Cpmolar&#39;][1], None)
    def Cpmolar(self):
        return self._AbstractState.cpmolar()

    @property
    @ureg.wraps(CP_const_unit[&#39;Cpmass&#39;][1], None)
    def Cpmass(self):
        return self._AbstractState.cpmass()

    @property
    @ureg.wraps(CP_const_unit[&#39;Cvmolar&#39;][1], None)
    def Cvmolar(self):
        return self._AbstractState.cvmolar()

    @property
    @ureg.wraps(CP_const_unit[&#39;Cvmass&#39;][1], None)
    def Cvmass(self):
        return self._AbstractState.cvmass()

    @property
    @ureg.wraps(CP_const_unit[&#39;viscosity&#39;][1], None)
    def viscosity(self):
        return self._AbstractState.viscosity()

    @property
    @ureg.wraps(CP_const_unit[&#39;conductivity&#39;][1], None)
    def conductivity(self):
        return self._AbstractState.conductivity()

    @property
    @ureg.wraps(CP_const_unit[&#39;surface_tension&#39;][1], None)
    def surface_tension(self):
        return self._AbstractState.surface_tension()

    @property
    @ureg.wraps(CP_const_unit[&#39;P&#39;][1], None)
    def P_reducing(self):
        return self._AbstractState.p_reducing()

    @property
    @ureg.wraps(CP_const_unit[&#39;P&#39;][1], None)
    def P_triple(self):
        return self._AbstractState.ptriple()

    @property
    @ureg.wraps(CP_const_unit[&#39;P&#39;][1], None)
    def P_max(self):
        return self._AbstractState.pmax()

    @property
    @ureg.wraps(CP_const_unit[&#39;T&#39;][1], None)
    def T_reducing(self):
        return self._AbstractState.T_reducing()

    @property
    @ureg.wraps(CP_const_unit[&#39;T&#39;][1], None)
    def T_triple(self):
        return self._AbstractState.Ttriple()

    @property
    @ureg.wraps(CP_const_unit[&#39;T&#39;][1], None)
    def T_max(self):
        return self._AbstractState.Tmax()

    @property
    @ureg.wraps(CP_const_unit[&#39;T&#39;][1], None)
    def T_min(self):
        return self._AbstractState.Tmin()

    @property
    @ureg.wraps(CP_const_unit[&#39;isothermal_compressibility&#39;][1], None)
    def isothermal_compressibility(self):
        return self._AbstractState.isothermal_compressibility()

    @property
    @ureg.wraps(CP_const_unit[&#39;isobaric_expansion_coefficient&#39;][1], None)
    def isobaric_expansion_coefficient(self):
        return self._AbstractState.isobaric_expansion_coefficient()

    @property
    @ureg.wraps(CP_const_unit[&#39;isentropic_expansion_coefficient&#39;][1], None)
    def isentropic_expansion_coefficient(self):
        return self._AbstractState.isentropic_expansion_coefficient()

    @property
    def Prandtl(self):
        return self._AbstractState.Prandtl()

    @property
    @ureg.wraps(CP_const_unit[&#39;speed_sound&#39;][1], None)
    def speed_sound(self):
        &#34;&#34;&#34;Mass fractions of a mixture.&#34;&#34;&#34;
        return self._AbstractState.speed_sound()

    def first_partial_deriv(self, Of, Wrt, Constant):
        output_unit = CP_const_unit[Of][1] / CP_const_unit[Wrt][1]
        Of_CP_const = CP_const_unit[Of][0]
        Wrt_CP_const = CP_const_unit[Wrt][0]
        Constant_CP_const = CP_const_unit[Constant][0]
        result = self._AbstractState.first_partial_deriv(
            Of_CP_const, Wrt_CP_const, Constant_CP_const)
        return result * output_unit

    @property
    @ureg.wraps(CP_const_unit[&#39;Phase&#39;][1], None)
    def phase(self):
        &#34;&#34;&#34;Calculate the phase of the fluid.

        * 0: Subcritical liquid
        * 1: Supercritical (p &gt; pc, T &gt; Tc)
        * 2: Supercritical gas (p &lt; pc, T &gt; Tc)
        * 3: Supercritical liquid (p &gt; pc, T &lt; Tc)
        * 4: At the critical point.
        * 5: Subcritical gas.
        * 6: Twophase.
        * 7: Unknown phase
        &#34;&#34;&#34;
        return self._AbstractState.phase()

    def set_mole_fractions(self, *fractions):
        &#34;&#34;&#34;Set mole fractions for a mixture.&#34;&#34;&#34;
        self._AbstractState.set_mole_fractions(fractions)

    def set_mass_fractions(self, *fractions):
        &#34;&#34;&#34;Set mass fractions for a mixture.&#34;&#34;&#34;
        self._AbstractState.set_mass_fractions(fractions)

    def set_volu_fractions(self, *fractions):
        &#34;&#34;&#34;Set volume fractions for a mixture.&#34;&#34;&#34;
        self._AbstractState.set_volu_fractions(fractions)

    @property
    def mole_fractions(self):
        &#34;&#34;&#34;Mole fractions of a mixture.&#34;&#34;&#34;
        return self._AbstractState.get_mole_fractions()

    @property
    def mass_fractions(self):
        &#34;&#34;&#34;Mass fractions of a mixture.&#34;&#34;&#34;
        return self._AbstractState.get_mass_fractions()

    @property
    def is_super_critical(self):
        &#34;&#34;&#34;Return True if state is supercritical.&#34;&#34;&#34;
        if self.phase in [1, 2, 3, 4]:
            return True
        elif self.phase in [0, 4, 5, 6]:
            return False
        else:
            raise ValueError(&#39;Phase is unknown&#39;)

    @property
    def specific_heat_input(self):
        &#34;&#34;&#34;
        Calculate Specific heat input, v * (dh/dv)|p.
        This function is not described in AbstractState class.
        &#34;&#34;&#34;
        # Because specific volume is not available as function of
        # the AbstractState, density is used instead
        # The resulting function is: -Dmass*(dHmass/dDmass)|p
        return (-self.Dmass) * self.first_partial_deriv(&#39;Hmass&#39;, &#39;Dmass&#39;, &#39;P&#39;)

    @property
    def gamma(self):
        &#34;&#34;&#34;Calculate gamma = k = Cp/Cv coefficient.
        &#34;&#34;&#34;
        # To avoid real gas effects influencing Cp and Cv,
        # calculating at gamma at NTP
        T_current = self.T
        S_current = self.Smass
        self.update(&#39;P&#39;, P_NTP, &#39;T&#39;, T_NTP)
        _gamma = self.Cpmass / self.Cvmass
        self.update(&#39;T&#39;, T_current, &#39;Smass&#39;, S_current)
        return _gamma

    @property
    def C_gas_const(self):
        &#34;&#34;&#34;
        Constant for gas or vapor which is the function of the ratio of
        specific heats k = Cp/Cv. ASME VIII.1-2015 pp. 423-424.
        &#34;&#34;&#34;
        k_ = self.gamma.magnitude
        root = (k_ * (2/(k_+1))**((k_+1)/(k_-1)))**0.5
        R = ureg.R  # Universal gas constant
        C_ = root / R**0.5 * (ureg.g/ureg.mol)**0.5
        return C_

    @property
    def C(self):
        &#34;&#34;&#34;A shortcut to C_gas_const&#34;&#34;&#34;
        return self.C_gas_const

    @property
    def C_us(self):
        &#34;&#34;&#34;A shortcut to C_gas_const for US customary units&#34;&#34;&#34;
        us_unit = ureg.lb/(ureg.hr*ureg.lbf)*(ureg.degR)**0.5
        return self.C_gas_const.to(us_unit)

    @property
    def C_si(self):
        &#34;&#34;&#34;A shortcut to C_gas_const for SI units&#34;&#34;&#34;
        si_unit = ureg.s**2/(ureg.hr*ureg.m)*(ureg.K)**0.5
        return self.C_gas_const.to(si_unit)

    @property
    def name(self):
        &#34;&#34;&#34;
        Return fluid name (backend dependent)
        &#34;&#34;&#34;
        return self._AbstractState.name()

    @property
    def backend(self):
        &#34;&#34;&#34;
        Return backend name
        &#34;&#34;&#34;
        return self._AbstractState.backend_name()

    def __str__(self):
        return f&#39;{self.name.capitalize()} at &#39; + \
            f&#39;T: {self.T.to(ureg.K):.3~g~} and &#39; + \
            f&#39;P: {self.P.to(ureg.psi):.3g~}.&#39;

    @property
    def M(self):
        &#34;&#34;&#34;Calculate relative molecular mass.&#34;&#34;&#34;
        return self.molar_mass.m_as(ureg.g/ureg.mole)

    @property
    def MZT(self):
        &#34;&#34;&#34;
        Calculate sqrt(M/(ZT)) a commonly used square root group for discharge
        flow calculation.
        &#34;&#34;&#34;
        MZT_ = (self.M / (self.compressibility_factor*self.T))**0.5
        return MZT_

    @property
    def latent_heat(self):
        &#34;&#34;&#34;Calculate latent heat of evaporation for current quality.&#34;&#34;&#34;
        assert self.is_super_critical is False, (
            &#39;Latent heat is only defined &#39;
            &#39;for subcritical phase&#39;)
        TempState = self.copy()
        TempState.update_kw(P=self.P, Q=0)
        h_liq = TempState.Hmass
        TempState = self.copy()
        TempState.update_kw(P=self.P, Q=1)
        h_gas = TempState.Hmass
        return h_gas - h_liq

    def copy(self):
        &#34;&#34;&#34;Create a copy of current ThermState object.&#34;&#34;&#34;
        TempState = ThermState(self.name, backend=self.backend)
        # If conditions are defined
        if self.Dmass != -inf*ureg.kg/ureg.m**3:
            TempState.update_kw(T=self.T, Smass=self.Smass)
        return TempState

    def to_standard(self, conditions=&#39;NTP&#39;):
        &#34;&#34;&#34;Create a copy of current ThermState object at standard conditions.
        &#34;&#34;&#34;
        if conditions == &#39;NTP&#39;:
            P = P_NTP
            T = T_NTP
        elif conditions == &#39;MSC&#39;:
            P = P_MSC
            T = T_MSC
        elif conditions == &#39;STD&#39;:
            P = P_STD
            T = T_STD
        else:
            raise ValueError(f&#39;Conditions {conditions!r} are not defined.&#39;)
        TempState = self.copy()
        TempState.update_kw(P=P, T=T)
        return TempState</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="CryoToolBox.cp_wrapper.ThermState"><code class="flex name class">
<span>class <span class="ident">ThermState</span></span>
<span>(</span><span>fluid, backend='HEOS', **state_parameters)</span>
</code></dt>
<dd>
<div class="desc"><p>Available backends: HEOS (opensource), REFPROP.
See <a href="http://www.coolprop.org/coolprop/REFPROP.html">http://www.coolprop.org/coolprop/REFPROP.html</a> for details.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class ThermState:
    def __init__(self, fluid, backend=&#34;HEOS&#34;, **state_parameters):
        &#34;&#34;&#34;
        Available backends: HEOS (opensource), REFPROP.
        See http://www.coolprop.org/coolprop/REFPROP.html for details.
        &#34;&#34;&#34;
        self._AbstractState = CP.AbstractState(backend, fluid)
        if state_parameters:
            self.update_kw(**state_parameters)

    def update_kw(self, **state_parameters):
        &#34;&#34;&#34;Update thermodynamic state using keyword arguments.&#34;&#34;&#34;
        if len(state_parameters) != 2:
            raise TypeError(f&#39;update_kw() takes 2 arguments \
            ({len(state_parameters)} given)&#39;)
        # TODO Code below can be simplified
        names = []
        values = []
        for name, value in state_parameters.items():
            names.append(name)
            values.append(value)
        self.update(names[0], values[0],
                    names[1], values[1])

    def update(self, name1, value1, name2, value2):
        if name1 &gt; name2:  # Sorting inputs alphabetically
            name1, name2 = name2, name1
            value1, value2 = value2, value1
        CP_input_str = name1 + name2
        CP_value1 = self.prepare_input(name1, value1)
        CP_value2 = self.prepare_input(name2, value2)
        self._AbstractState.update(
            CP_inputs[CP_input_str], CP_value1, CP_value2)

    @staticmethod
    def prepare_input(name, value):
        &#34;&#34;&#34;Prepare value to input to CoolProp.

        Converts the value to units expected by CoolProp
        (see `CP_const_unit`).

        Parameters
        ----------
        name : str
            Parameter name.
        value : ureg.Quantity
            Parameter value.

        Returns
        -------
        float
        &#34;&#34;&#34;
        if isinstance(value, (int, float)):
            return value  # Dimensionless
        else:
            unit = CP_const_unit[name][1]
            return value.to(unit).magnitude

    @property
    @ureg.wraps(CP_const_unit[&#39;T&#39;][1], None)
    def T_critical(self):
        return self._AbstractState.T_critical()

    @property
    @ureg.wraps(CP_const_unit[&#39;P&#39;][1], None)
    def P_critical(self):
        return self._AbstractState.p_critical()

    @property
    @ureg.wraps(CP_const_unit[&#39;Dmolar_critical&#39;][1], None)
    def Dmolar_critical(self):
        return self._AbstractState.rhomolar_critical()

    @property
    @ureg.wraps(CP_const_unit[&#39;Dmass_critical&#39;][1], None)
    def Dmass_critical(self):
        return self._AbstractState.rhomass_critical()

    @property
    @ureg.wraps(CP_const_unit[&#39;T&#39;][1], None)
    def T(self):
        return self._AbstractState.T()

    @property
    @ureg.wraps(CP_const_unit[&#39;Dmolar_critical&#39;][1], None)
    def Dmolar(self):
        return self._AbstractState.rhomolar()

    @property
    @ureg.wraps(CP_const_unit[&#39;Dmass_critical&#39;][1], None)
    def Dmass(self):
        return self._AbstractState.rhomass()

    @property
    @ureg.wraps(CP_const_unit[&#39;P&#39;][1], None)
    def P(self):
        return self._AbstractState.p()

    @property
    @ureg.wraps(CP_const_unit[&#39;Q&#39;][1], None)
    def Q(self):
        return self._AbstractState.Q()

    @property
    @ureg.wraps(CP_const_unit[&#39;molar_mass&#39;][1], None)
    def molar_mass(self):
        return self._AbstractState.molar_mass()

    @property
    @ureg.wraps(CP_const_unit[&#39;gas_constant&#39;][1], None)
    def gas_constant(self):
        return self._AbstractState.gas_constant()

    @property
    def specific_gas_constant(self):
        R_spec = self.gas_constant / self.molar_mass
        return R_spec

    @property
    # @ureg.wraps(CP_const_unit[&#39;Z&#39;][1], None)
    def compressibility_factor(self):
        Z_ = self.P * self.molar_mass / (self.Dmass*self.gas_constant*self.T)
        return Z_.m_as(ureg.dimensionless)
        # Temporarily unavailable function
        # return self._AbstractState.compressibility_factor()
    # Useful shorthand
    Z = compressibility_factor

    @property
    @ureg.wraps(CP_const_unit[&#39;Hmolar&#39;][1], None)
    def Hmolar(self):
        return self._AbstractState.hmolar()

    @property
    @ureg.wraps(CP_const_unit[&#39;Hmass&#39;][1], None)
    def Hmass(self):
        return self._AbstractState.hmass()

    @property
    @ureg.wraps(CP_const_unit[&#39;Smolar&#39;][1], None)
    def Smolar(self):
        return self._AbstractState.smolar()

    @property
    @ureg.wraps(CP_const_unit[&#39;Smass&#39;][1], None)
    def Smass(self):
        return self._AbstractState.smass()

    @property
    @ureg.wraps(CP_const_unit[&#39;Cpmolar&#39;][1], None)
    def Cpmolar(self):
        return self._AbstractState.cpmolar()

    @property
    @ureg.wraps(CP_const_unit[&#39;Cpmass&#39;][1], None)
    def Cpmass(self):
        return self._AbstractState.cpmass()

    @property
    @ureg.wraps(CP_const_unit[&#39;Cvmolar&#39;][1], None)
    def Cvmolar(self):
        return self._AbstractState.cvmolar()

    @property
    @ureg.wraps(CP_const_unit[&#39;Cvmass&#39;][1], None)
    def Cvmass(self):
        return self._AbstractState.cvmass()

    @property
    @ureg.wraps(CP_const_unit[&#39;viscosity&#39;][1], None)
    def viscosity(self):
        return self._AbstractState.viscosity()

    @property
    @ureg.wraps(CP_const_unit[&#39;conductivity&#39;][1], None)
    def conductivity(self):
        return self._AbstractState.conductivity()

    @property
    @ureg.wraps(CP_const_unit[&#39;surface_tension&#39;][1], None)
    def surface_tension(self):
        return self._AbstractState.surface_tension()

    @property
    @ureg.wraps(CP_const_unit[&#39;P&#39;][1], None)
    def P_reducing(self):
        return self._AbstractState.p_reducing()

    @property
    @ureg.wraps(CP_const_unit[&#39;P&#39;][1], None)
    def P_triple(self):
        return self._AbstractState.ptriple()

    @property
    @ureg.wraps(CP_const_unit[&#39;P&#39;][1], None)
    def P_max(self):
        return self._AbstractState.pmax()

    @property
    @ureg.wraps(CP_const_unit[&#39;T&#39;][1], None)
    def T_reducing(self):
        return self._AbstractState.T_reducing()

    @property
    @ureg.wraps(CP_const_unit[&#39;T&#39;][1], None)
    def T_triple(self):
        return self._AbstractState.Ttriple()

    @property
    @ureg.wraps(CP_const_unit[&#39;T&#39;][1], None)
    def T_max(self):
        return self._AbstractState.Tmax()

    @property
    @ureg.wraps(CP_const_unit[&#39;T&#39;][1], None)
    def T_min(self):
        return self._AbstractState.Tmin()

    @property
    @ureg.wraps(CP_const_unit[&#39;isothermal_compressibility&#39;][1], None)
    def isothermal_compressibility(self):
        return self._AbstractState.isothermal_compressibility()

    @property
    @ureg.wraps(CP_const_unit[&#39;isobaric_expansion_coefficient&#39;][1], None)
    def isobaric_expansion_coefficient(self):
        return self._AbstractState.isobaric_expansion_coefficient()

    @property
    @ureg.wraps(CP_const_unit[&#39;isentropic_expansion_coefficient&#39;][1], None)
    def isentropic_expansion_coefficient(self):
        return self._AbstractState.isentropic_expansion_coefficient()

    @property
    def Prandtl(self):
        return self._AbstractState.Prandtl()

    @property
    @ureg.wraps(CP_const_unit[&#39;speed_sound&#39;][1], None)
    def speed_sound(self):
        &#34;&#34;&#34;Mass fractions of a mixture.&#34;&#34;&#34;
        return self._AbstractState.speed_sound()

    def first_partial_deriv(self, Of, Wrt, Constant):
        output_unit = CP_const_unit[Of][1] / CP_const_unit[Wrt][1]
        Of_CP_const = CP_const_unit[Of][0]
        Wrt_CP_const = CP_const_unit[Wrt][0]
        Constant_CP_const = CP_const_unit[Constant][0]
        result = self._AbstractState.first_partial_deriv(
            Of_CP_const, Wrt_CP_const, Constant_CP_const)
        return result * output_unit

    @property
    @ureg.wraps(CP_const_unit[&#39;Phase&#39;][1], None)
    def phase(self):
        &#34;&#34;&#34;Calculate the phase of the fluid.

        * 0: Subcritical liquid
        * 1: Supercritical (p &gt; pc, T &gt; Tc)
        * 2: Supercritical gas (p &lt; pc, T &gt; Tc)
        * 3: Supercritical liquid (p &gt; pc, T &lt; Tc)
        * 4: At the critical point.
        * 5: Subcritical gas.
        * 6: Twophase.
        * 7: Unknown phase
        &#34;&#34;&#34;
        return self._AbstractState.phase()

    def set_mole_fractions(self, *fractions):
        &#34;&#34;&#34;Set mole fractions for a mixture.&#34;&#34;&#34;
        self._AbstractState.set_mole_fractions(fractions)

    def set_mass_fractions(self, *fractions):
        &#34;&#34;&#34;Set mass fractions for a mixture.&#34;&#34;&#34;
        self._AbstractState.set_mass_fractions(fractions)

    def set_volu_fractions(self, *fractions):
        &#34;&#34;&#34;Set volume fractions for a mixture.&#34;&#34;&#34;
        self._AbstractState.set_volu_fractions(fractions)

    @property
    def mole_fractions(self):
        &#34;&#34;&#34;Mole fractions of a mixture.&#34;&#34;&#34;
        return self._AbstractState.get_mole_fractions()

    @property
    def mass_fractions(self):
        &#34;&#34;&#34;Mass fractions of a mixture.&#34;&#34;&#34;
        return self._AbstractState.get_mass_fractions()

    @property
    def is_super_critical(self):
        &#34;&#34;&#34;Return True if state is supercritical.&#34;&#34;&#34;
        if self.phase in [1, 2, 3, 4]:
            return True
        elif self.phase in [0, 4, 5, 6]:
            return False
        else:
            raise ValueError(&#39;Phase is unknown&#39;)

    @property
    def specific_heat_input(self):
        &#34;&#34;&#34;
        Calculate Specific heat input, v * (dh/dv)|p.
        This function is not described in AbstractState class.
        &#34;&#34;&#34;
        # Because specific volume is not available as function of
        # the AbstractState, density is used instead
        # The resulting function is: -Dmass*(dHmass/dDmass)|p
        return (-self.Dmass) * self.first_partial_deriv(&#39;Hmass&#39;, &#39;Dmass&#39;, &#39;P&#39;)

    @property
    def gamma(self):
        &#34;&#34;&#34;Calculate gamma = k = Cp/Cv coefficient.
        &#34;&#34;&#34;
        # To avoid real gas effects influencing Cp and Cv,
        # calculating at gamma at NTP
        T_current = self.T
        S_current = self.Smass
        self.update(&#39;P&#39;, P_NTP, &#39;T&#39;, T_NTP)
        _gamma = self.Cpmass / self.Cvmass
        self.update(&#39;T&#39;, T_current, &#39;Smass&#39;, S_current)
        return _gamma

    @property
    def C_gas_const(self):
        &#34;&#34;&#34;
        Constant for gas or vapor which is the function of the ratio of
        specific heats k = Cp/Cv. ASME VIII.1-2015 pp. 423-424.
        &#34;&#34;&#34;
        k_ = self.gamma.magnitude
        root = (k_ * (2/(k_+1))**((k_+1)/(k_-1)))**0.5
        R = ureg.R  # Universal gas constant
        C_ = root / R**0.5 * (ureg.g/ureg.mol)**0.5
        return C_

    @property
    def C(self):
        &#34;&#34;&#34;A shortcut to C_gas_const&#34;&#34;&#34;
        return self.C_gas_const

    @property
    def C_us(self):
        &#34;&#34;&#34;A shortcut to C_gas_const for US customary units&#34;&#34;&#34;
        us_unit = ureg.lb/(ureg.hr*ureg.lbf)*(ureg.degR)**0.5
        return self.C_gas_const.to(us_unit)

    @property
    def C_si(self):
        &#34;&#34;&#34;A shortcut to C_gas_const for SI units&#34;&#34;&#34;
        si_unit = ureg.s**2/(ureg.hr*ureg.m)*(ureg.K)**0.5
        return self.C_gas_const.to(si_unit)

    @property
    def name(self):
        &#34;&#34;&#34;
        Return fluid name (backend dependent)
        &#34;&#34;&#34;
        return self._AbstractState.name()

    @property
    def backend(self):
        &#34;&#34;&#34;
        Return backend name
        &#34;&#34;&#34;
        return self._AbstractState.backend_name()

    def __str__(self):
        return f&#39;{self.name.capitalize()} at &#39; + \
            f&#39;T: {self.T.to(ureg.K):.3~g~} and &#39; + \
            f&#39;P: {self.P.to(ureg.psi):.3g~}.&#39;

    @property
    def M(self):
        &#34;&#34;&#34;Calculate relative molecular mass.&#34;&#34;&#34;
        return self.molar_mass.m_as(ureg.g/ureg.mole)

    @property
    def MZT(self):
        &#34;&#34;&#34;
        Calculate sqrt(M/(ZT)) a commonly used square root group for discharge
        flow calculation.
        &#34;&#34;&#34;
        MZT_ = (self.M / (self.compressibility_factor*self.T))**0.5
        return MZT_

    @property
    def latent_heat(self):
        &#34;&#34;&#34;Calculate latent heat of evaporation for current quality.&#34;&#34;&#34;
        assert self.is_super_critical is False, (
            &#39;Latent heat is only defined &#39;
            &#39;for subcritical phase&#39;)
        TempState = self.copy()
        TempState.update_kw(P=self.P, Q=0)
        h_liq = TempState.Hmass
        TempState = self.copy()
        TempState.update_kw(P=self.P, Q=1)
        h_gas = TempState.Hmass
        return h_gas - h_liq

    def copy(self):
        &#34;&#34;&#34;Create a copy of current ThermState object.&#34;&#34;&#34;
        TempState = ThermState(self.name, backend=self.backend)
        # If conditions are defined
        if self.Dmass != -inf*ureg.kg/ureg.m**3:
            TempState.update_kw(T=self.T, Smass=self.Smass)
        return TempState

    def to_standard(self, conditions=&#39;NTP&#39;):
        &#34;&#34;&#34;Create a copy of current ThermState object at standard conditions.
        &#34;&#34;&#34;
        if conditions == &#39;NTP&#39;:
            P = P_NTP
            T = T_NTP
        elif conditions == &#39;MSC&#39;:
            P = P_MSC
            T = T_MSC
        elif conditions == &#39;STD&#39;:
            P = P_STD
            T = T_STD
        else:
            raise ValueError(f&#39;Conditions {conditions!r} are not defined.&#39;)
        TempState = self.copy()
        TempState.update_kw(P=P, T=T)
        return TempState</code></pre>
</details>
<h3>Static methods</h3>
<dl>
<dt id="CryoToolBox.cp_wrapper.ThermState.prepare_input"><code class="name flex">
<span>def <span class="ident">prepare_input</span></span>(<span>name, value)</span>
</code></dt>
<dd>
<div class="desc"><p>Prepare value to input to CoolProp.</p>
<p>Converts the value to units expected by CoolProp
(see <code>CP_const_unit</code>).</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>name</code></strong> :&ensp;<code>str</code></dt>
<dd>Parameter name.</dd>
<dt><strong><code>value</code></strong> :&ensp;<code>ureg.Quantity</code></dt>
<dd>Parameter value.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>float</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def prepare_input(name, value):
    &#34;&#34;&#34;Prepare value to input to CoolProp.

    Converts the value to units expected by CoolProp
    (see `CP_const_unit`).

    Parameters
    ----------
    name : str
        Parameter name.
    value : ureg.Quantity
        Parameter value.

    Returns
    -------
    float
    &#34;&#34;&#34;
    if isinstance(value, (int, float)):
        return value  # Dimensionless
    else:
        unit = CP_const_unit[name][1]
        return value.to(unit).magnitude</code></pre>
</details>
</dd>
</dl>
<h3>Instance variables</h3>
<dl>
<dt id="CryoToolBox.cp_wrapper.ThermState.C"><code class="name">var <span class="ident">C</span></code></dt>
<dd>
<div class="desc"><p>A shortcut to C_gas_const</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def C(self):
    &#34;&#34;&#34;A shortcut to C_gas_const&#34;&#34;&#34;
    return self.C_gas_const</code></pre>
</details>
</dd>
<dt id="CryoToolBox.cp_wrapper.ThermState.C_gas_const"><code class="name">var <span class="ident">C_gas_const</span></code></dt>
<dd>
<div class="desc"><p>Constant for gas or vapor which is the function of the ratio of
specific heats k = Cp/Cv. ASME VIII.1-2015 pp. 423-424.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def C_gas_const(self):
    &#34;&#34;&#34;
    Constant for gas or vapor which is the function of the ratio of
    specific heats k = Cp/Cv. ASME VIII.1-2015 pp. 423-424.
    &#34;&#34;&#34;
    k_ = self.gamma.magnitude
    root = (k_ * (2/(k_+1))**((k_+1)/(k_-1)))**0.5
    R = ureg.R  # Universal gas constant
    C_ = root / R**0.5 * (ureg.g/ureg.mol)**0.5
    return C_</code></pre>
</details>
</dd>
<dt id="CryoToolBox.cp_wrapper.ThermState.C_si"><code class="name">var <span class="ident">C_si</span></code></dt>
<dd>
<div class="desc"><p>A shortcut to C_gas_const for SI units</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def C_si(self):
    &#34;&#34;&#34;A shortcut to C_gas_const for SI units&#34;&#34;&#34;
    si_unit = ureg.s**2/(ureg.hr*ureg.m)*(ureg.K)**0.5
    return self.C_gas_const.to(si_unit)</code></pre>
</details>
</dd>
<dt id="CryoToolBox.cp_wrapper.ThermState.C_us"><code class="name">var <span class="ident">C_us</span></code></dt>
<dd>
<div class="desc"><p>A shortcut to C_gas_const for US customary units</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def C_us(self):
    &#34;&#34;&#34;A shortcut to C_gas_const for US customary units&#34;&#34;&#34;
    us_unit = ureg.lb/(ureg.hr*ureg.lbf)*(ureg.degR)**0.5
    return self.C_gas_const.to(us_unit)</code></pre>
</details>
</dd>
<dt id="CryoToolBox.cp_wrapper.ThermState.Cpmass"><code class="name">var <span class="ident">Cpmass</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
@ureg.wraps(CP_const_unit[&#39;Cpmass&#39;][1], None)
def Cpmass(self):
    return self._AbstractState.cpmass()</code></pre>
</details>
</dd>
<dt id="CryoToolBox.cp_wrapper.ThermState.Cpmolar"><code class="name">var <span class="ident">Cpmolar</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
@ureg.wraps(CP_const_unit[&#39;Cpmolar&#39;][1], None)
def Cpmolar(self):
    return self._AbstractState.cpmolar()</code></pre>
</details>
</dd>
<dt id="CryoToolBox.cp_wrapper.ThermState.Cvmass"><code class="name">var <span class="ident">Cvmass</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
@ureg.wraps(CP_const_unit[&#39;Cvmass&#39;][1], None)
def Cvmass(self):
    return self._AbstractState.cvmass()</code></pre>
</details>
</dd>
<dt id="CryoToolBox.cp_wrapper.ThermState.Cvmolar"><code class="name">var <span class="ident">Cvmolar</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
@ureg.wraps(CP_const_unit[&#39;Cvmolar&#39;][1], None)
def Cvmolar(self):
    return self._AbstractState.cvmolar()</code></pre>
</details>
</dd>
<dt id="CryoToolBox.cp_wrapper.ThermState.Dmass"><code class="name">var <span class="ident">Dmass</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
@ureg.wraps(CP_const_unit[&#39;Dmass_critical&#39;][1], None)
def Dmass(self):
    return self._AbstractState.rhomass()</code></pre>
</details>
</dd>
<dt id="CryoToolBox.cp_wrapper.ThermState.Dmass_critical"><code class="name">var <span class="ident">Dmass_critical</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
@ureg.wraps(CP_const_unit[&#39;Dmass_critical&#39;][1], None)
def Dmass_critical(self):
    return self._AbstractState.rhomass_critical()</code></pre>
</details>
</dd>
<dt id="CryoToolBox.cp_wrapper.ThermState.Dmolar"><code class="name">var <span class="ident">Dmolar</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
@ureg.wraps(CP_const_unit[&#39;Dmolar_critical&#39;][1], None)
def Dmolar(self):
    return self._AbstractState.rhomolar()</code></pre>
</details>
</dd>
<dt id="CryoToolBox.cp_wrapper.ThermState.Dmolar_critical"><code class="name">var <span class="ident">Dmolar_critical</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
@ureg.wraps(CP_const_unit[&#39;Dmolar_critical&#39;][1], None)
def Dmolar_critical(self):
    return self._AbstractState.rhomolar_critical()</code></pre>
</details>
</dd>
<dt id="CryoToolBox.cp_wrapper.ThermState.Hmass"><code class="name">var <span class="ident">Hmass</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
@ureg.wraps(CP_const_unit[&#39;Hmass&#39;][1], None)
def Hmass(self):
    return self._AbstractState.hmass()</code></pre>
</details>
</dd>
<dt id="CryoToolBox.cp_wrapper.ThermState.Hmolar"><code class="name">var <span class="ident">Hmolar</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
@ureg.wraps(CP_const_unit[&#39;Hmolar&#39;][1], None)
def Hmolar(self):
    return self._AbstractState.hmolar()</code></pre>
</details>
</dd>
<dt id="CryoToolBox.cp_wrapper.ThermState.M"><code class="name">var <span class="ident">M</span></code></dt>
<dd>
<div class="desc"><p>Calculate relative molecular mass.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def M(self):
    &#34;&#34;&#34;Calculate relative molecular mass.&#34;&#34;&#34;
    return self.molar_mass.m_as(ureg.g/ureg.mole)</code></pre>
</details>
</dd>
<dt id="CryoToolBox.cp_wrapper.ThermState.MZT"><code class="name">var <span class="ident">MZT</span></code></dt>
<dd>
<div class="desc"><p>Calculate sqrt(M/(ZT)) a commonly used square root group for discharge
flow calculation.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def MZT(self):
    &#34;&#34;&#34;
    Calculate sqrt(M/(ZT)) a commonly used square root group for discharge
    flow calculation.
    &#34;&#34;&#34;
    MZT_ = (self.M / (self.compressibility_factor*self.T))**0.5
    return MZT_</code></pre>
</details>
</dd>
<dt id="CryoToolBox.cp_wrapper.ThermState.P"><code class="name">var <span class="ident">P</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
@ureg.wraps(CP_const_unit[&#39;P&#39;][1], None)
def P(self):
    return self._AbstractState.p()</code></pre>
</details>
</dd>
<dt id="CryoToolBox.cp_wrapper.ThermState.P_critical"><code class="name">var <span class="ident">P_critical</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
@ureg.wraps(CP_const_unit[&#39;P&#39;][1], None)
def P_critical(self):
    return self._AbstractState.p_critical()</code></pre>
</details>
</dd>
<dt id="CryoToolBox.cp_wrapper.ThermState.P_max"><code class="name">var <span class="ident">P_max</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
@ureg.wraps(CP_const_unit[&#39;P&#39;][1], None)
def P_max(self):
    return self._AbstractState.pmax()</code></pre>
</details>
</dd>
<dt id="CryoToolBox.cp_wrapper.ThermState.P_reducing"><code class="name">var <span class="ident">P_reducing</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
@ureg.wraps(CP_const_unit[&#39;P&#39;][1], None)
def P_reducing(self):
    return self._AbstractState.p_reducing()</code></pre>
</details>
</dd>
<dt id="CryoToolBox.cp_wrapper.ThermState.P_triple"><code class="name">var <span class="ident">P_triple</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
@ureg.wraps(CP_const_unit[&#39;P&#39;][1], None)
def P_triple(self):
    return self._AbstractState.ptriple()</code></pre>
</details>
</dd>
<dt id="CryoToolBox.cp_wrapper.ThermState.Prandtl"><code class="name">var <span class="ident">Prandtl</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def Prandtl(self):
    return self._AbstractState.Prandtl()</code></pre>
</details>
</dd>
<dt id="CryoToolBox.cp_wrapper.ThermState.Q"><code class="name">var <span class="ident">Q</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
@ureg.wraps(CP_const_unit[&#39;Q&#39;][1], None)
def Q(self):
    return self._AbstractState.Q()</code></pre>
</details>
</dd>
<dt id="CryoToolBox.cp_wrapper.ThermState.Smass"><code class="name">var <span class="ident">Smass</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
@ureg.wraps(CP_const_unit[&#39;Smass&#39;][1], None)
def Smass(self):
    return self._AbstractState.smass()</code></pre>
</details>
</dd>
<dt id="CryoToolBox.cp_wrapper.ThermState.Smolar"><code class="name">var <span class="ident">Smolar</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
@ureg.wraps(CP_const_unit[&#39;Smolar&#39;][1], None)
def Smolar(self):
    return self._AbstractState.smolar()</code></pre>
</details>
</dd>
<dt id="CryoToolBox.cp_wrapper.ThermState.T"><code class="name">var <span class="ident">T</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
@ureg.wraps(CP_const_unit[&#39;T&#39;][1], None)
def T(self):
    return self._AbstractState.T()</code></pre>
</details>
</dd>
<dt id="CryoToolBox.cp_wrapper.ThermState.T_critical"><code class="name">var <span class="ident">T_critical</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
@ureg.wraps(CP_const_unit[&#39;T&#39;][1], None)
def T_critical(self):
    return self._AbstractState.T_critical()</code></pre>
</details>
</dd>
<dt id="CryoToolBox.cp_wrapper.ThermState.T_max"><code class="name">var <span class="ident">T_max</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
@ureg.wraps(CP_const_unit[&#39;T&#39;][1], None)
def T_max(self):
    return self._AbstractState.Tmax()</code></pre>
</details>
</dd>
<dt id="CryoToolBox.cp_wrapper.ThermState.T_min"><code class="name">var <span class="ident">T_min</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
@ureg.wraps(CP_const_unit[&#39;T&#39;][1], None)
def T_min(self):
    return self._AbstractState.Tmin()</code></pre>
</details>
</dd>
<dt id="CryoToolBox.cp_wrapper.ThermState.T_reducing"><code class="name">var <span class="ident">T_reducing</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
@ureg.wraps(CP_const_unit[&#39;T&#39;][1], None)
def T_reducing(self):
    return self._AbstractState.T_reducing()</code></pre>
</details>
</dd>
<dt id="CryoToolBox.cp_wrapper.ThermState.T_triple"><code class="name">var <span class="ident">T_triple</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
@ureg.wraps(CP_const_unit[&#39;T&#39;][1], None)
def T_triple(self):
    return self._AbstractState.Ttriple()</code></pre>
</details>
</dd>
<dt id="CryoToolBox.cp_wrapper.ThermState.Z"><code class="name">var <span class="ident">Z</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
# @ureg.wraps(CP_const_unit[&#39;Z&#39;][1], None)
def compressibility_factor(self):
    Z_ = self.P * self.molar_mass / (self.Dmass*self.gas_constant*self.T)
    return Z_.m_as(ureg.dimensionless)
    # Temporarily unavailable function
    # return self._AbstractState.compressibility_factor()</code></pre>
</details>
</dd>
<dt id="CryoToolBox.cp_wrapper.ThermState.backend"><code class="name">var <span class="ident">backend</span></code></dt>
<dd>
<div class="desc"><p>Return backend name</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def backend(self):
    &#34;&#34;&#34;
    Return backend name
    &#34;&#34;&#34;
    return self._AbstractState.backend_name()</code></pre>
</details>
</dd>
<dt id="CryoToolBox.cp_wrapper.ThermState.compressibility_factor"><code class="name">var <span class="ident">compressibility_factor</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
# @ureg.wraps(CP_const_unit[&#39;Z&#39;][1], None)
def compressibility_factor(self):
    Z_ = self.P * self.molar_mass / (self.Dmass*self.gas_constant*self.T)
    return Z_.m_as(ureg.dimensionless)
    # Temporarily unavailable function
    # return self._AbstractState.compressibility_factor()</code></pre>
</details>
</dd>
<dt id="CryoToolBox.cp_wrapper.ThermState.conductivity"><code class="name">var <span class="ident">conductivity</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
@ureg.wraps(CP_const_unit[&#39;conductivity&#39;][1], None)
def conductivity(self):
    return self._AbstractState.conductivity()</code></pre>
</details>
</dd>
<dt id="CryoToolBox.cp_wrapper.ThermState.gamma"><code class="name">var <span class="ident">gamma</span></code></dt>
<dd>
<div class="desc"><p>Calculate gamma = k = Cp/Cv coefficient.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def gamma(self):
    &#34;&#34;&#34;Calculate gamma = k = Cp/Cv coefficient.
    &#34;&#34;&#34;
    # To avoid real gas effects influencing Cp and Cv,
    # calculating at gamma at NTP
    T_current = self.T
    S_current = self.Smass
    self.update(&#39;P&#39;, P_NTP, &#39;T&#39;, T_NTP)
    _gamma = self.Cpmass / self.Cvmass
    self.update(&#39;T&#39;, T_current, &#39;Smass&#39;, S_current)
    return _gamma</code></pre>
</details>
</dd>
<dt id="CryoToolBox.cp_wrapper.ThermState.gas_constant"><code class="name">var <span class="ident">gas_constant</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
@ureg.wraps(CP_const_unit[&#39;gas_constant&#39;][1], None)
def gas_constant(self):
    return self._AbstractState.gas_constant()</code></pre>
</details>
</dd>
<dt id="CryoToolBox.cp_wrapper.ThermState.is_super_critical"><code class="name">var <span class="ident">is_super_critical</span></code></dt>
<dd>
<div class="desc"><p>Return True if state is supercritical.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def is_super_critical(self):
    &#34;&#34;&#34;Return True if state is supercritical.&#34;&#34;&#34;
    if self.phase in [1, 2, 3, 4]:
        return True
    elif self.phase in [0, 4, 5, 6]:
        return False
    else:
        raise ValueError(&#39;Phase is unknown&#39;)</code></pre>
</details>
</dd>
<dt id="CryoToolBox.cp_wrapper.ThermState.isentropic_expansion_coefficient"><code class="name">var <span class="ident">isentropic_expansion_coefficient</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
@ureg.wraps(CP_const_unit[&#39;isentropic_expansion_coefficient&#39;][1], None)
def isentropic_expansion_coefficient(self):
    return self._AbstractState.isentropic_expansion_coefficient()</code></pre>
</details>
</dd>
<dt id="CryoToolBox.cp_wrapper.ThermState.isobaric_expansion_coefficient"><code class="name">var <span class="ident">isobaric_expansion_coefficient</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
@ureg.wraps(CP_const_unit[&#39;isobaric_expansion_coefficient&#39;][1], None)
def isobaric_expansion_coefficient(self):
    return self._AbstractState.isobaric_expansion_coefficient()</code></pre>
</details>
</dd>
<dt id="CryoToolBox.cp_wrapper.ThermState.isothermal_compressibility"><code class="name">var <span class="ident">isothermal_compressibility</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
@ureg.wraps(CP_const_unit[&#39;isothermal_compressibility&#39;][1], None)
def isothermal_compressibility(self):
    return self._AbstractState.isothermal_compressibility()</code></pre>
</details>
</dd>
<dt id="CryoToolBox.cp_wrapper.ThermState.latent_heat"><code class="name">var <span class="ident">latent_heat</span></code></dt>
<dd>
<div class="desc"><p>Calculate latent heat of evaporation for current quality.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def latent_heat(self):
    &#34;&#34;&#34;Calculate latent heat of evaporation for current quality.&#34;&#34;&#34;
    assert self.is_super_critical is False, (
        &#39;Latent heat is only defined &#39;
        &#39;for subcritical phase&#39;)
    TempState = self.copy()
    TempState.update_kw(P=self.P, Q=0)
    h_liq = TempState.Hmass
    TempState = self.copy()
    TempState.update_kw(P=self.P, Q=1)
    h_gas = TempState.Hmass
    return h_gas - h_liq</code></pre>
</details>
</dd>
<dt id="CryoToolBox.cp_wrapper.ThermState.mass_fractions"><code class="name">var <span class="ident">mass_fractions</span></code></dt>
<dd>
<div class="desc"><p>Mass fractions of a mixture.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def mass_fractions(self):
    &#34;&#34;&#34;Mass fractions of a mixture.&#34;&#34;&#34;
    return self._AbstractState.get_mass_fractions()</code></pre>
</details>
</dd>
<dt id="CryoToolBox.cp_wrapper.ThermState.molar_mass"><code class="name">var <span class="ident">molar_mass</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
@ureg.wraps(CP_const_unit[&#39;molar_mass&#39;][1], None)
def molar_mass(self):
    return self._AbstractState.molar_mass()</code></pre>
</details>
</dd>
<dt id="CryoToolBox.cp_wrapper.ThermState.mole_fractions"><code class="name">var <span class="ident">mole_fractions</span></code></dt>
<dd>
<div class="desc"><p>Mole fractions of a mixture.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def mole_fractions(self):
    &#34;&#34;&#34;Mole fractions of a mixture.&#34;&#34;&#34;
    return self._AbstractState.get_mole_fractions()</code></pre>
</details>
</dd>
<dt id="CryoToolBox.cp_wrapper.ThermState.name"><code class="name">var <span class="ident">name</span></code></dt>
<dd>
<div class="desc"><p>Return fluid name (backend dependent)</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def name(self):
    &#34;&#34;&#34;
    Return fluid name (backend dependent)
    &#34;&#34;&#34;
    return self._AbstractState.name()</code></pre>
</details>
</dd>
<dt id="CryoToolBox.cp_wrapper.ThermState.phase"><code class="name">var <span class="ident">phase</span></code></dt>
<dd>
<div class="desc"><p>Calculate the phase of the fluid.</p>
<ul>
<li>0: Subcritical liquid</li>
<li>1: Supercritical (p &gt; pc, T &gt; Tc)</li>
<li>2: Supercritical gas (p &lt; pc, T &gt; Tc)</li>
<li>3: Supercritical liquid (p &gt; pc, T &lt; Tc)</li>
<li>4: At the critical point.</li>
<li>5: Subcritical gas.</li>
<li>6: Twophase.</li>
<li>7: Unknown phase</li>
</ul></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
@ureg.wraps(CP_const_unit[&#39;Phase&#39;][1], None)
def phase(self):
    &#34;&#34;&#34;Calculate the phase of the fluid.

    * 0: Subcritical liquid
    * 1: Supercritical (p &gt; pc, T &gt; Tc)
    * 2: Supercritical gas (p &lt; pc, T &gt; Tc)
    * 3: Supercritical liquid (p &gt; pc, T &lt; Tc)
    * 4: At the critical point.
    * 5: Subcritical gas.
    * 6: Twophase.
    * 7: Unknown phase
    &#34;&#34;&#34;
    return self._AbstractState.phase()</code></pre>
</details>
</dd>
<dt id="CryoToolBox.cp_wrapper.ThermState.specific_gas_constant"><code class="name">var <span class="ident">specific_gas_constant</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def specific_gas_constant(self):
    R_spec = self.gas_constant / self.molar_mass
    return R_spec</code></pre>
</details>
</dd>
<dt id="CryoToolBox.cp_wrapper.ThermState.specific_heat_input"><code class="name">var <span class="ident">specific_heat_input</span></code></dt>
<dd>
<div class="desc"><p>Calculate Specific heat input, v * (dh/dv)|p.
This function is not described in AbstractState class.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
def specific_heat_input(self):
    &#34;&#34;&#34;
    Calculate Specific heat input, v * (dh/dv)|p.
    This function is not described in AbstractState class.
    &#34;&#34;&#34;
    # Because specific volume is not available as function of
    # the AbstractState, density is used instead
    # The resulting function is: -Dmass*(dHmass/dDmass)|p
    return (-self.Dmass) * self.first_partial_deriv(&#39;Hmass&#39;, &#39;Dmass&#39;, &#39;P&#39;)</code></pre>
</details>
</dd>
<dt id="CryoToolBox.cp_wrapper.ThermState.speed_sound"><code class="name">var <span class="ident">speed_sound</span></code></dt>
<dd>
<div class="desc"><p>Mass fractions of a mixture.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
@ureg.wraps(CP_const_unit[&#39;speed_sound&#39;][1], None)
def speed_sound(self):
    &#34;&#34;&#34;Mass fractions of a mixture.&#34;&#34;&#34;
    return self._AbstractState.speed_sound()</code></pre>
</details>
</dd>
<dt id="CryoToolBox.cp_wrapper.ThermState.surface_tension"><code class="name">var <span class="ident">surface_tension</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
@ureg.wraps(CP_const_unit[&#39;surface_tension&#39;][1], None)
def surface_tension(self):
    return self._AbstractState.surface_tension()</code></pre>
</details>
</dd>
<dt id="CryoToolBox.cp_wrapper.ThermState.viscosity"><code class="name">var <span class="ident">viscosity</span></code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@property
@ureg.wraps(CP_const_unit[&#39;viscosity&#39;][1], None)
def viscosity(self):
    return self._AbstractState.viscosity()</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="CryoToolBox.cp_wrapper.ThermState.copy"><code class="name flex">
<span>def <span class="ident">copy</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Create a copy of current ThermState object.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def copy(self):
    &#34;&#34;&#34;Create a copy of current ThermState object.&#34;&#34;&#34;
    TempState = ThermState(self.name, backend=self.backend)
    # If conditions are defined
    if self.Dmass != -inf*ureg.kg/ureg.m**3:
        TempState.update_kw(T=self.T, Smass=self.Smass)
    return TempState</code></pre>
</details>
</dd>
<dt id="CryoToolBox.cp_wrapper.ThermState.first_partial_deriv"><code class="name flex">
<span>def <span class="ident">first_partial_deriv</span></span>(<span>self, Of, Wrt, Constant)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def first_partial_deriv(self, Of, Wrt, Constant):
    output_unit = CP_const_unit[Of][1] / CP_const_unit[Wrt][1]
    Of_CP_const = CP_const_unit[Of][0]
    Wrt_CP_const = CP_const_unit[Wrt][0]
    Constant_CP_const = CP_const_unit[Constant][0]
    result = self._AbstractState.first_partial_deriv(
        Of_CP_const, Wrt_CP_const, Constant_CP_const)
    return result * output_unit</code></pre>
</details>
</dd>
<dt id="CryoToolBox.cp_wrapper.ThermState.set_mass_fractions"><code class="name flex">
<span>def <span class="ident">set_mass_fractions</span></span>(<span>self, *fractions)</span>
</code></dt>
<dd>
<div class="desc"><p>Set mass fractions for a mixture.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_mass_fractions(self, *fractions):
    &#34;&#34;&#34;Set mass fractions for a mixture.&#34;&#34;&#34;
    self._AbstractState.set_mass_fractions(fractions)</code></pre>
</details>
</dd>
<dt id="CryoToolBox.cp_wrapper.ThermState.set_mole_fractions"><code class="name flex">
<span>def <span class="ident">set_mole_fractions</span></span>(<span>self, *fractions)</span>
</code></dt>
<dd>
<div class="desc"><p>Set mole fractions for a mixture.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_mole_fractions(self, *fractions):
    &#34;&#34;&#34;Set mole fractions for a mixture.&#34;&#34;&#34;
    self._AbstractState.set_mole_fractions(fractions)</code></pre>
</details>
</dd>
<dt id="CryoToolBox.cp_wrapper.ThermState.set_volu_fractions"><code class="name flex">
<span>def <span class="ident">set_volu_fractions</span></span>(<span>self, *fractions)</span>
</code></dt>
<dd>
<div class="desc"><p>Set volume fractions for a mixture.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def set_volu_fractions(self, *fractions):
    &#34;&#34;&#34;Set volume fractions for a mixture.&#34;&#34;&#34;
    self._AbstractState.set_volu_fractions(fractions)</code></pre>
</details>
</dd>
<dt id="CryoToolBox.cp_wrapper.ThermState.to_standard"><code class="name flex">
<span>def <span class="ident">to_standard</span></span>(<span>self, conditions='NTP')</span>
</code></dt>
<dd>
<div class="desc"><p>Create a copy of current ThermState object at standard conditions.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def to_standard(self, conditions=&#39;NTP&#39;):
    &#34;&#34;&#34;Create a copy of current ThermState object at standard conditions.
    &#34;&#34;&#34;
    if conditions == &#39;NTP&#39;:
        P = P_NTP
        T = T_NTP
    elif conditions == &#39;MSC&#39;:
        P = P_MSC
        T = T_MSC
    elif conditions == &#39;STD&#39;:
        P = P_STD
        T = T_STD
    else:
        raise ValueError(f&#39;Conditions {conditions!r} are not defined.&#39;)
    TempState = self.copy()
    TempState.update_kw(P=P, T=T)
    return TempState</code></pre>
</details>
</dd>
<dt id="CryoToolBox.cp_wrapper.ThermState.update"><code class="name flex">
<span>def <span class="ident">update</span></span>(<span>self, name1, value1, name2, value2)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def update(self, name1, value1, name2, value2):
    if name1 &gt; name2:  # Sorting inputs alphabetically
        name1, name2 = name2, name1
        value1, value2 = value2, value1
    CP_input_str = name1 + name2
    CP_value1 = self.prepare_input(name1, value1)
    CP_value2 = self.prepare_input(name2, value2)
    self._AbstractState.update(
        CP_inputs[CP_input_str], CP_value1, CP_value2)</code></pre>
</details>
</dd>
<dt id="CryoToolBox.cp_wrapper.ThermState.update_kw"><code class="name flex">
<span>def <span class="ident">update_kw</span></span>(<span>self, **state_parameters)</span>
</code></dt>
<dd>
<div class="desc"><p>Update thermodynamic state using keyword arguments.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def update_kw(self, **state_parameters):
    &#34;&#34;&#34;Update thermodynamic state using keyword arguments.&#34;&#34;&#34;
    if len(state_parameters) != 2:
        raise TypeError(f&#39;update_kw() takes 2 arguments \
        ({len(state_parameters)} given)&#39;)
    # TODO Code below can be simplified
    names = []
    values = []
    for name, value in state_parameters.items():
        names.append(name)
        values.append(value)
    self.update(names[0], values[0],
                names[1], values[1])</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="CryoToolBox" href="index.html">CryoToolBox</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="CryoToolBox.cp_wrapper.ThermState" href="#CryoToolBox.cp_wrapper.ThermState">ThermState</a></code></h4>
<ul class="">
<li><code><a title="CryoToolBox.cp_wrapper.ThermState.C" href="#CryoToolBox.cp_wrapper.ThermState.C">C</a></code></li>
<li><code><a title="CryoToolBox.cp_wrapper.ThermState.C_gas_const" href="#CryoToolBox.cp_wrapper.ThermState.C_gas_const">C_gas_const</a></code></li>
<li><code><a title="CryoToolBox.cp_wrapper.ThermState.C_si" href="#CryoToolBox.cp_wrapper.ThermState.C_si">C_si</a></code></li>
<li><code><a title="CryoToolBox.cp_wrapper.ThermState.C_us" href="#CryoToolBox.cp_wrapper.ThermState.C_us">C_us</a></code></li>
<li><code><a title="CryoToolBox.cp_wrapper.ThermState.Cpmass" href="#CryoToolBox.cp_wrapper.ThermState.Cpmass">Cpmass</a></code></li>
<li><code><a title="CryoToolBox.cp_wrapper.ThermState.Cpmolar" href="#CryoToolBox.cp_wrapper.ThermState.Cpmolar">Cpmolar</a></code></li>
<li><code><a title="CryoToolBox.cp_wrapper.ThermState.Cvmass" href="#CryoToolBox.cp_wrapper.ThermState.Cvmass">Cvmass</a></code></li>
<li><code><a title="CryoToolBox.cp_wrapper.ThermState.Cvmolar" href="#CryoToolBox.cp_wrapper.ThermState.Cvmolar">Cvmolar</a></code></li>
<li><code><a title="CryoToolBox.cp_wrapper.ThermState.Dmass" href="#CryoToolBox.cp_wrapper.ThermState.Dmass">Dmass</a></code></li>
<li><code><a title="CryoToolBox.cp_wrapper.ThermState.Dmass_critical" href="#CryoToolBox.cp_wrapper.ThermState.Dmass_critical">Dmass_critical</a></code></li>
<li><code><a title="CryoToolBox.cp_wrapper.ThermState.Dmolar" href="#CryoToolBox.cp_wrapper.ThermState.Dmolar">Dmolar</a></code></li>
<li><code><a title="CryoToolBox.cp_wrapper.ThermState.Dmolar_critical" href="#CryoToolBox.cp_wrapper.ThermState.Dmolar_critical">Dmolar_critical</a></code></li>
<li><code><a title="CryoToolBox.cp_wrapper.ThermState.Hmass" href="#CryoToolBox.cp_wrapper.ThermState.Hmass">Hmass</a></code></li>
<li><code><a title="CryoToolBox.cp_wrapper.ThermState.Hmolar" href="#CryoToolBox.cp_wrapper.ThermState.Hmolar">Hmolar</a></code></li>
<li><code><a title="CryoToolBox.cp_wrapper.ThermState.M" href="#CryoToolBox.cp_wrapper.ThermState.M">M</a></code></li>
<li><code><a title="CryoToolBox.cp_wrapper.ThermState.MZT" href="#CryoToolBox.cp_wrapper.ThermState.MZT">MZT</a></code></li>
<li><code><a title="CryoToolBox.cp_wrapper.ThermState.P" href="#CryoToolBox.cp_wrapper.ThermState.P">P</a></code></li>
<li><code><a title="CryoToolBox.cp_wrapper.ThermState.P_critical" href="#CryoToolBox.cp_wrapper.ThermState.P_critical">P_critical</a></code></li>
<li><code><a title="CryoToolBox.cp_wrapper.ThermState.P_max" href="#CryoToolBox.cp_wrapper.ThermState.P_max">P_max</a></code></li>
<li><code><a title="CryoToolBox.cp_wrapper.ThermState.P_reducing" href="#CryoToolBox.cp_wrapper.ThermState.P_reducing">P_reducing</a></code></li>
<li><code><a title="CryoToolBox.cp_wrapper.ThermState.P_triple" href="#CryoToolBox.cp_wrapper.ThermState.P_triple">P_triple</a></code></li>
<li><code><a title="CryoToolBox.cp_wrapper.ThermState.Prandtl" href="#CryoToolBox.cp_wrapper.ThermState.Prandtl">Prandtl</a></code></li>
<li><code><a title="CryoToolBox.cp_wrapper.ThermState.Q" href="#CryoToolBox.cp_wrapper.ThermState.Q">Q</a></code></li>
<li><code><a title="CryoToolBox.cp_wrapper.ThermState.Smass" href="#CryoToolBox.cp_wrapper.ThermState.Smass">Smass</a></code></li>
<li><code><a title="CryoToolBox.cp_wrapper.ThermState.Smolar" href="#CryoToolBox.cp_wrapper.ThermState.Smolar">Smolar</a></code></li>
<li><code><a title="CryoToolBox.cp_wrapper.ThermState.T" href="#CryoToolBox.cp_wrapper.ThermState.T">T</a></code></li>
<li><code><a title="CryoToolBox.cp_wrapper.ThermState.T_critical" href="#CryoToolBox.cp_wrapper.ThermState.T_critical">T_critical</a></code></li>
<li><code><a title="CryoToolBox.cp_wrapper.ThermState.T_max" href="#CryoToolBox.cp_wrapper.ThermState.T_max">T_max</a></code></li>
<li><code><a title="CryoToolBox.cp_wrapper.ThermState.T_min" href="#CryoToolBox.cp_wrapper.ThermState.T_min">T_min</a></code></li>
<li><code><a title="CryoToolBox.cp_wrapper.ThermState.T_reducing" href="#CryoToolBox.cp_wrapper.ThermState.T_reducing">T_reducing</a></code></li>
<li><code><a title="CryoToolBox.cp_wrapper.ThermState.T_triple" href="#CryoToolBox.cp_wrapper.ThermState.T_triple">T_triple</a></code></li>
<li><code><a title="CryoToolBox.cp_wrapper.ThermState.Z" href="#CryoToolBox.cp_wrapper.ThermState.Z">Z</a></code></li>
<li><code><a title="CryoToolBox.cp_wrapper.ThermState.backend" href="#CryoToolBox.cp_wrapper.ThermState.backend">backend</a></code></li>
<li><code><a title="CryoToolBox.cp_wrapper.ThermState.compressibility_factor" href="#CryoToolBox.cp_wrapper.ThermState.compressibility_factor">compressibility_factor</a></code></li>
<li><code><a title="CryoToolBox.cp_wrapper.ThermState.conductivity" href="#CryoToolBox.cp_wrapper.ThermState.conductivity">conductivity</a></code></li>
<li><code><a title="CryoToolBox.cp_wrapper.ThermState.copy" href="#CryoToolBox.cp_wrapper.ThermState.copy">copy</a></code></li>
<li><code><a title="CryoToolBox.cp_wrapper.ThermState.first_partial_deriv" href="#CryoToolBox.cp_wrapper.ThermState.first_partial_deriv">first_partial_deriv</a></code></li>
<li><code><a title="CryoToolBox.cp_wrapper.ThermState.gamma" href="#CryoToolBox.cp_wrapper.ThermState.gamma">gamma</a></code></li>
<li><code><a title="CryoToolBox.cp_wrapper.ThermState.gas_constant" href="#CryoToolBox.cp_wrapper.ThermState.gas_constant">gas_constant</a></code></li>
<li><code><a title="CryoToolBox.cp_wrapper.ThermState.is_super_critical" href="#CryoToolBox.cp_wrapper.ThermState.is_super_critical">is_super_critical</a></code></li>
<li><code><a title="CryoToolBox.cp_wrapper.ThermState.isentropic_expansion_coefficient" href="#CryoToolBox.cp_wrapper.ThermState.isentropic_expansion_coefficient">isentropic_expansion_coefficient</a></code></li>
<li><code><a title="CryoToolBox.cp_wrapper.ThermState.isobaric_expansion_coefficient" href="#CryoToolBox.cp_wrapper.ThermState.isobaric_expansion_coefficient">isobaric_expansion_coefficient</a></code></li>
<li><code><a title="CryoToolBox.cp_wrapper.ThermState.isothermal_compressibility" href="#CryoToolBox.cp_wrapper.ThermState.isothermal_compressibility">isothermal_compressibility</a></code></li>
<li><code><a title="CryoToolBox.cp_wrapper.ThermState.latent_heat" href="#CryoToolBox.cp_wrapper.ThermState.latent_heat">latent_heat</a></code></li>
<li><code><a title="CryoToolBox.cp_wrapper.ThermState.mass_fractions" href="#CryoToolBox.cp_wrapper.ThermState.mass_fractions">mass_fractions</a></code></li>
<li><code><a title="CryoToolBox.cp_wrapper.ThermState.molar_mass" href="#CryoToolBox.cp_wrapper.ThermState.molar_mass">molar_mass</a></code></li>
<li><code><a title="CryoToolBox.cp_wrapper.ThermState.mole_fractions" href="#CryoToolBox.cp_wrapper.ThermState.mole_fractions">mole_fractions</a></code></li>
<li><code><a title="CryoToolBox.cp_wrapper.ThermState.name" href="#CryoToolBox.cp_wrapper.ThermState.name">name</a></code></li>
<li><code><a title="CryoToolBox.cp_wrapper.ThermState.phase" href="#CryoToolBox.cp_wrapper.ThermState.phase">phase</a></code></li>
<li><code><a title="CryoToolBox.cp_wrapper.ThermState.prepare_input" href="#CryoToolBox.cp_wrapper.ThermState.prepare_input">prepare_input</a></code></li>
<li><code><a title="CryoToolBox.cp_wrapper.ThermState.set_mass_fractions" href="#CryoToolBox.cp_wrapper.ThermState.set_mass_fractions">set_mass_fractions</a></code></li>
<li><code><a title="CryoToolBox.cp_wrapper.ThermState.set_mole_fractions" href="#CryoToolBox.cp_wrapper.ThermState.set_mole_fractions">set_mole_fractions</a></code></li>
<li><code><a title="CryoToolBox.cp_wrapper.ThermState.set_volu_fractions" href="#CryoToolBox.cp_wrapper.ThermState.set_volu_fractions">set_volu_fractions</a></code></li>
<li><code><a title="CryoToolBox.cp_wrapper.ThermState.specific_gas_constant" href="#CryoToolBox.cp_wrapper.ThermState.specific_gas_constant">specific_gas_constant</a></code></li>
<li><code><a title="CryoToolBox.cp_wrapper.ThermState.specific_heat_input" href="#CryoToolBox.cp_wrapper.ThermState.specific_heat_input">specific_heat_input</a></code></li>
<li><code><a title="CryoToolBox.cp_wrapper.ThermState.speed_sound" href="#CryoToolBox.cp_wrapper.ThermState.speed_sound">speed_sound</a></code></li>
<li><code><a title="CryoToolBox.cp_wrapper.ThermState.surface_tension" href="#CryoToolBox.cp_wrapper.ThermState.surface_tension">surface_tension</a></code></li>
<li><code><a title="CryoToolBox.cp_wrapper.ThermState.to_standard" href="#CryoToolBox.cp_wrapper.ThermState.to_standard">to_standard</a></code></li>
<li><code><a title="CryoToolBox.cp_wrapper.ThermState.update" href="#CryoToolBox.cp_wrapper.ThermState.update">update</a></code></li>
<li><code><a title="CryoToolBox.cp_wrapper.ThermState.update_kw" href="#CryoToolBox.cp_wrapper.ThermState.update_kw">update_kw</a></code></li>
<li><code><a title="CryoToolBox.cp_wrapper.ThermState.viscosity" href="#CryoToolBox.cp_wrapper.ThermState.viscosity">viscosity</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>